Repository Structure:
├── .vscode
├── bulk_task.py
├── data
│   └── storage
├── docs
├── extract.py
├── extract2.py
├── jira_telegram_bot
│   ├── __init__.py
│   ├── __main__.py
│   ├── __pycache__
│   ├── adapters
│   │   ├── __init__.py
│   │   ├── __pycache__
│   │   ├── ai_models
│   │   │   ├── __init__.py
│   │   │   ├── __pycache__
│   │   │   ├── openai_model.py
│   │   │   └── speech_processor.py
│   │   ├── batch_task_creation.py
│   │   ├── deadline_notifier.py
│   │   ├── fetch_store_gitlab_commits.py
│   │   ├── gateways
│   │   │   └── __init__.py
│   │   ├── google_sheet.py
│   │   ├── repositories
│   │   │   ├── __init__.py
│   │   │   ├── __pycache__
│   │   │   ├── file_storage
│   │   │   │   ├── __init__.py
│   │   │   │   └── __pycache__
│   │   │   ├── jira
│   │   │   │   ├── __init__.py
│   │   │   │   ├── __pycache__
│   │   │   │   └── jira_server_repository.py
│   │   │   └── postgres
│   │   │       └── __init__.py
│   │   ├── services
│   │   │   ├── __init__.py
│   │   │   ├── __pycache__
│   │   │   └── telegram
│   │   │       ├── __init__.py
│   │   │       ├── __pycache__
│   │   │       ├── authentication.py
│   │   │       └── telegram_gateway.py
│   │   ├── user_config.py
│   │   └── utils
│   │       └── change_priority_schema.py
│   ├── app_container.py
│   ├── entities
│   │   ├── __init__.py
│   │   ├── __pycache__
│   │   ├── field_config.py
│   │   ├── speech.py
│   │   ├── task.py
│   │   └── user_config.py
│   ├── frameworks
│   │   ├── __init__.py
│   │   ├── __pycache__
│   │   ├── fast_api
│   │   │   ├── __init__.py
│   │   │   ├── __pycache__
│   │   │   ├── create_ticket.py
│   │   │   ├── create_ticket_controller.py
│   │   │   ├── jira_webhook_controller.py
│   │   │   └── telegram_webhook_controller.py
│   │   └── telegram
│   │       ├── __init__.py
│   │       ├── __pycache__
│   │       ├── advanced_task_creation_handler.py
│   │       ├── board_summary_generator_handler.py
│   │       ├── task_creation_handler.py
│   │       ├── task_get_users_time_handler.py
│   │       ├── task_status_handler.py
│   │       ├── task_transition_handler.py
│   │       ├── user_settings_handler.py
│   │       └── voice.py
│   ├── settings
│   │   ├── __init__.py
│   │   ├── __pycache__
│   │   ├── gemini_settings.py
│   │   ├── gitlab_settings.py
│   │   ├── google_sheets_settings.py
│   │   ├── jira_board_config.py
│   │   ├── jira_settings.py
│   │   ├── openai_settings.py
│   │   ├── postgre_db_settings.py
│   │   ├── telegram_settings.py
│   ├── ticketing_bot.py
│   ├── use_cases
│   │   ├── __init__.py
│   │   ├── __pycache__
│   │   ├── ai_agents
│   │   │   ├── __init__.py
│   │   │   ├── __pycache__
│   │   │   ├── create_ticketing_issue.py
│   │   │   ├── parse_jira_prompt_usecase.py
│   │   │   └── prompts.py
│   │   ├── create_task_usecase.py
│   │   ├── handle_jira_webhook_usecase.py
│   │   ├── interface
│   │   │   ├── __init__.py
│   │   │   ├── __pycache__
│   │   │   ├── openai_gateway_interface.py
│   │   │   ├── speech_processor_interface.py
│   │   │   ├── summary_generator_interface.py
│   │   │   ├── task_grouper_interface.py
│   │   │   ├── task_handler_interface.py
│   │   │   ├── task_interface.py
│   │   │   ├── task_manager_repository_interface.py
│   │   │   ├── telegram_gateway_interface.py
│   │   │   └── user_config_interface.py
│   │   ├── report.py
│   │   ├── reports_full.py
│   │   └── telegram_commands
│   │       ├── __init__.py
│   │       ├── __pycache__
│   │       ├── advanced_task_creation.py
│   │       ├── board_summarizer.py
│   │       ├── board_summary_generator.py
│   │       ├── create_task.py
│   │       ├── task_get_users_time.py
│   │       ├── task_status.py
│   │       ├── transition_task.py
│   │       └── user_settings.py
│   └── utils
│       ├── ___init__.py
│       ├── __pycache__
│       ├── basic_logger.py
│       ├── check_version.py
│       ├── data_store.py
│       ├── jalali_georgian_calendar.py
│       ├── markdown_cleaner.py
│       ├── pydantic_advanced_settings.py
│       ├── speech_utils.py
├── jira_telegram_bot.egg-info
├── kubernetes
├── scripts
├── setup.py
└── tests
    ├── __pycache__
    ├── samples
    ├── test_issue_logs.py
    ├── test_set_fix_version_label.py
    ├── test_tempo.py
    └── unit_tests
        ├── test_advanced_task_creation.py
        └── use_cases
            ├── __pycache__
            └── test_create_easy_task.py

================================================================================
File: /home/ali/project/jirabot/bulk_task.py
================================================================================

Imports:
from __future__ import annotations
import argparse
import asyncio
import sys
import dotenv
from jira_telegram_bot import LOGGER, DEFAULT_PATH
from jira_telegram_bot.adapters.google_sheet import create_tasks_from_sheet
from jira_telegram_bot.settings import GOOGLE_SHEETS_SETTINGS
from jira_telegram_bot.adapters.google_sheet import GoogleSheetClient, SheetRepository

Global Initiations:
created_issues = await create_tasks_from_sheet()
parser = argparse.ArgumentParser(description='Create Jira tasks from Google Sheet assignments')
args = parser.parse_args()
settings_valid = await validate_settings(args)
sheet_client = GoogleSheetClient(GOOGLE_SHEETS_SETTINGS.token_path)
repository = SheetRepository(sheet_client)
assignments = repository.get_assignment_records(GOOGLE_SHEETS_SETTINGS.sheet_id, GOOGLE_SHEETS_SETTINGS.worksheet_name)

__main__ Section:
if __name__ == '__main__':
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        LOGGER.info('Process interrupted by user')
        sys.exit(1)
    except Exception as e:
        LOGGER.error(f'Error in main process: {e}')
        sys.exit(1)

Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/setup.py
================================================================================

Imports:
import logging
import re
import subprocess
from pathlib import Path
from typing import List
from setuptools import setup, find_packages

Global Initiations:
logger = logging.getLogger(__name__)
console_handler = logging.StreamHandler()
install_requires = check_requirements(install_requires)
installed_pacakges_idx = []
install_requires = [x for x in install_requires if x != '']
file = Path('./jira_telegram_bot/__init__.py')
install_requires = f.read().splitlines()
result = subprocess.run(f'pip install {package}', shell=True, capture_output=True, text=True)

__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/extract.py
================================================================================

Imports:
from __future__ import annotations
import ast
import os

Global Initiations:
tree = []
tree = ast.parse(source_code)
imports = []
global_initiations = []
main_section = []
classes = {}
params = []
return_type = ast.unparse(func_node.returns) if func_node.returns else 'None'
repo_tree = '\n'.join(get_repo_tree(directory))
target_directory = './'
entries = sorted(os.listdir(directory))
entries = [e for e in entries if not e.startswith('.git') and (not e.endswith('.pyc'))]
source_code = file.read()
arg_name = arg.arg
arg_type = ast.unparse(arg.annotation) if arg.annotation else 'Any'
entry_path = os.path.join(directory, entry)
is_last = index == len(entries) - 1
new_prefix = prefix + ('    ' if is_last else '│   ')
filepath = os.path.join(root, file)
methods = {}
method_signature = extract_function_signature(sub_node)

__main__ Section:
if __name__ == '__main__':
    target_directory = './'
    process_directory(target_directory)

Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/app_container.py
================================================================================

Imports:
from __future__ import annotations
from lagom import Container
from lagom.integrations.fast_api import FastApiIntegration
from jira_telegram_bot.adapters.repositories.jira.jira_server_repository import JiraRepository
from jira_telegram_bot.adapters.ai_models.openai_model import OpenAIGateway
from jira_telegram_bot.adapters.ai_models.speech_processor import SpeechProcessor
from jira_telegram_bot.adapters.services.telegram.telegram_gateway import TelegramGateway
from jira_telegram_bot.use_cases.create_task_usecase import CreateTaskUseCase
from jira_telegram_bot.use_cases.handle_jira_webhook_usecase import HandleJiraWebhookUseCase
from jira_telegram_bot.use_cases.interface.openai_gateway_interface import OpenAIGatewayInterface
from jira_telegram_bot.use_cases.interface.speech_processor_interface import SpeechProcessorInterface
from jira_telegram_bot.use_cases.interface.task_manager_repository_interface import TaskManagerRepositoryInterface
from jira_telegram_bot.use_cases.interface.telegram_gateway_interface import TelegramGatewayInterface
from jira_telegram_bot.use_cases.ai_agents.parse_jira_prompt_usecase import ParseJiraPromptUseCase

Global Initiations:
container = Container()
container = create_container()
deps = FastApiIntegration(container)

__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/__main__.py
================================================================================

Imports:
from __future__ import annotations
import traceback
from warnings import filterwarnings
from telegram.ext import Application
from telegram.ext import CommandHandler
from telegram.warnings import PTBUserWarning
from jira_telegram_bot import LOGGER
from jira_telegram_bot.adapters.repositories.jira.jira_server_repository import JiraRepository
from jira_telegram_bot.adapters.ai_models.speech_processor import SpeechProcessor
from jira_telegram_bot.adapters.user_config import UserConfig
from jira_telegram_bot.frameworks.telegram.advanced_task_creation_handler import AdvancedTaskCreationHandler
from jira_telegram_bot.frameworks.telegram.board_summary_generator_handler import BoardSummaryGeneratorHandler
from jira_telegram_bot.frameworks.telegram.task_creation_handler import TaskCreationHandler
from jira_telegram_bot.frameworks.telegram.task_get_users_time_handler import TaskGetUsersTimeHandler
from jira_telegram_bot.frameworks.telegram.task_status_handler import TaskStatusHandler
from jira_telegram_bot.frameworks.telegram.task_transition_handler import TaskTransitionHandler
from jira_telegram_bot.frameworks.telegram.user_settings_handler import UserSettingsHandler
from jira_telegram_bot.settings import OPENAI_SETTINGS
from jira_telegram_bot.settings import TELEGRAM_SETTINGS
from jira_telegram_bot.use_cases.telegram_commands.advanced_task_creation import AdvancedTaskCreation
from jira_telegram_bot.use_cases.telegram_commands.board_summarizer import create_llm_chain
from jira_telegram_bot.use_cases.telegram_commands.board_summarizer import TaskProcessor
from jira_telegram_bot.use_cases.telegram_commands.board_summary_generator import BoardSummaryGenerator
from jira_telegram_bot.use_cases.telegram_commands.create_task import JiraTaskCreation
from jira_telegram_bot.use_cases.telegram_commands.task_get_users_time import TaskGetUsersTime
from jira_telegram_bot.use_cases.telegram_commands.task_status import TaskStatus
from jira_telegram_bot.use_cases.telegram_commands.transition_task import JiraTaskTransition
from jira_telegram_bot.use_cases.telegram_commands.user_settings import UserSettingsConversation

Global Initiations:
llm_chain = create_llm_chain(OPENAI_SETTINGS)
summary_generator = TaskProcessor(llm_chain)
help_text = "Here's how to use this bot:\n\n1. **/create_task** - Start creating a new task.\n2. **/transition** - Transition an existing task.\n3. **/status** - Get the status of a task.\n4. **/summary_tasks** - Get a summary of completed tasks and tasks that are ready for review\n5. **/setting** - Update user settings\n6. **/get_users_time** - Get users' time spent on tasks\n7. **/advanced_task** - Create multiple related tasks using AI-powered task breakdown\n8. **/cancel** - Cancel the current running operation"
application = Application.builder().token(TELEGRAM_SETTINGS.TOKEN).read_timeout(20).connect_timeout(20).build()
jira_repo = JiraRepository()
user_config_instance = UserConfig()
speech_processor = SpeechProcessor()
task_creation_use_case = JiraTaskCreation(jira_repo, user_config_instance)
task_status_use_case = TaskStatus(jira_repo.jira)
task_transition_use_case = JiraTaskTransition(jira_repo.jira)
user_settings_use_case = UserSettingsConversation(user_config_instance, ['alikaz3mi'])
task_get_users_time_use_case = TaskGetUsersTime(jira_repo, ['alikaz3mi', 'hamed_ahmadi1991'])
board_summary_generator_use_case = BoardSummaryGenerator(jira_repo, summary_generator)
advanced_task_creation_use_case = AdvancedTaskCreation(jira_repo, user_config_instance)
task_creation_handler = TaskCreationHandler(task_creation_use_case)
task_status_handler = TaskStatusHandler(task_status_use_case)
task_transition_handler = TaskTransitionHandler(task_transition_use_case)
user_settings_handler = UserSettingsHandler(user_settings_use_case)
board_summary_generator_handler = BoardSummaryGeneratorHandler(board_summary_generator_use_case)
task_get_users_time_handler = TaskGetUsersTimeHandler(task_get_users_time_use_case)
advanced_task_creation_handler = AdvancedTaskCreationHandler(advanced_task_creation_use_case, speech_processor)
tb = traceback.extract_tb(e.__traceback__)
formatted_tb = traceback.format_list(tb)

__main__ Section:
if __name__ == '__main__':
    main()

Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/__init__.py
================================================================================

Imports:
from __future__ import annotations
import os
from pathlib import Path
from jira_telegram_bot.utils.basic_logger import loguru_logger

Global Initiations:
__version__ = '2.30.27'
__name__ = 'jira_telegram_bot'
DEFAULT_PATH = Path(os.path.realpath(__file__)).parents[1]
LOGGER = loguru_logger(__name__)
__all__ = ['__version__', '__name__', 'loguru_logger', 'DEFAULT_PATH']

__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/ticketing_bot.py
================================================================================

Imports:
from __future__ import annotations
import uvicorn
from jira_telegram_bot.frameworks.fast_api.create_ticket_controller import app

Global Initiations:


__main__ Section:
if __name__ == '__main__':
    uvicorn.run(app, host='0.0.0.0', port=2315, reload=True)

Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/tests/test_set_fix_version_label.py
================================================================================

Imports:
from __future__ import annotations
from jira_telegram_bot.adapters.repositories.jira.jira_server_repository import JiraRepository
from jira_telegram_bot.settings import JIRA_SETTINGS

Global Initiations:
jira = JiraRepository(JIRA_SETTINGS)
jql = 'project = PARSCHAT AND issuetype = Story'
issues = jira.jira.search_issues(jql, maxResults=1000)
fix_versions = [fv.name for fv in issue.fields.fixVersions]
new_labels = {f'{v.replace(' ', '-')}' for v in fix_versions}

__main__ Section:
if __name__ == '__main__':
    main()

Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/tests/test_tempo.py
================================================================================

Imports:
from __future__ import annotations
from jira_telegram_bot import LOGGER
from jira_telegram_bot.adapters.repositories.jira.jira_server_repository import JiraRepository
from jira_telegram_bot.settings import JIRA_SETTINGS

Global Initiations:
jira = JiraRepository(JIRA_SETTINGS)
issues = jira.jira.search_issues('project = PARSCHAT', maxResults=1000)
spent_time = sum([worklog.timeSpentSeconds for worklog in issue.fields.worklog.worklogs]) / 3600
remaining_time = int(issue.fields.customfield_10106 * 8 - spent_time) if int(issue.fields.customfield_10106 * 8 - spent_time) > 0 else 0

__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/tests/test_issue_logs.py
================================================================================

Imports:
from __future__ import annotations
from datetime import datetime
from datetime import timedelta
from jira_telegram_bot.adapters.repositories.jira.jira_server_repository import JiraRepository
from jira_telegram_bot.settings import JIRA_SETTINGS

Global Initiations:
jira = JiraRepository(JIRA_SETTINGS)
one_month_ago = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')
jql = f'updated >= {one_month_ago} ORDER BY updated DESC'
recent_issues = jira.jira.search_issues(jql, maxResults=1000)
all_issues = []
block_size = 100
block_num = 0
start_idx = block_num * block_size
issues_block = jira.search_issues(jql, startAt=start_idx, maxResults=block_size)

__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/entities/speech.py
================================================================================

Imports:
from __future__ import annotations
from typing import Optional
from pydantic import BaseModel
from pydantic import Field

Global Initiations:


__main__ Section:


Classes and Methods:
Class: TranscriptionResult


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/entities/user_config.py
================================================================================

Imports:
from __future__ import annotations
from typing import List
from typing import Optional
from pydantic import BaseModel

Global Initiations:


__main__ Section:


Classes and Methods:
Class: FieldConfig
Class: UserConfig


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/entities/__init__.py
================================================================================

Imports:


Global Initiations:


__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/entities/task.py
================================================================================

Imports:
from __future__ import annotations
from collections import defaultdict
from typing import Any
from typing import Dict
from typing import List
from typing import Optional
from jira import Issue
from pydantic import BaseModel
from pydantic import ConfigDict
from pydantic import Field

Global Initiations:
model_config = ConfigDict(arbitrary_types_allowed=True)

__main__ Section:


Classes and Methods:
Class: TaskData


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/entities/field_config.py
================================================================================

Imports:
from __future__ import annotations
from typing import List
from typing import Optional
from pydantic import BaseModel
from pydantic import Field

Global Initiations:


__main__ Section:


Classes and Methods:
Class: FieldConfig


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/handle_jira_webhook_usecase.py
================================================================================

Imports:
from __future__ import annotations
from typing import Any
from typing import Dict
from jira_telegram_bot import LOGGER
from jira_telegram_bot.settings import JIRA_SETTINGS
from jira_telegram_bot.use_cases.interface.telegram_gateway_interface import TelegramGatewayInterface
from jira_telegram_bot.utils.data_store import get_mapping_by_issue_key

Global Initiations:
event_type = webhook_body.get('issue_event_type_name')
issue_data = webhook_body.get('issue', {})
issue_key = issue_data.get('key')
mapping = get_mapping_by_issue_key(issue_key)
channel_chat_id = mapping.get('channel_chat_id')
group_chat_id = mapping.get('group_chat_id')
reply_message_id = mapping.get('reply_message_id')
summary = issue_data['fields'].get('summary', '')
creator_name = webhook_body.get('user', {}).get('displayName', 'someone')
msg = f'**Jira Event**\nIssue *created* by {creator_name}\nKey: {issue_data['key']}\nSummary: {summary}'
summary = issue_data['fields'].get('summary', '')
creator_name = webhook_body.get('user', {}).get('displayName', 'someone')
msg = f'🔔 *Jira Event*\n\n🔑 Issue Key: {JIRA_SETTINGS.domain}/browse/{issue_data['key']}\n\n📝 Summary: {summary}\n\n👤 Created by {creator_name}'
comment_info = webhook_body.get('comment')
changelog = webhook_body.get('changelog', {})
items = changelog.get('items', [])
commenter = comment_info['updateAuthor']['displayName']
comment_body = comment_info['body']
msg = f'**Jira Event**\nNew comment on *{issue_data['key']}* by {commenter}:\n\n{comment_body}'
from_str = change_item.get('fromString', '')
to_str = change_item.get('toString', '')
msg = f"**Jira Event**\nIssue *{issue_data['key']}* moved from '{from_str}' to '{to_str}'."

__main__ Section:


Classes and Methods:
Class: HandleJiraWebhookUseCase
  __init__ (self: Any, telegram_gateway: TelegramGatewayInterface) -> None
  run (self: Any, webhook_body: Dict[str, Any]) -> Dict[str, str]
  _handle_issue_created (self: Any, issue_data: Any, webhook_body: Any, channel_chat_id: Any, group_chat_id: Any, reply_message_id: Any) -> None
  _handle_issue_generic (self: Any, issue_data: Any, webhook_body: Any, channel_chat_id: Any, group_chat_id: Any, reply_message_id: Any) -> None
  _handle_issue_updated (self: Any, issue_data: Any, webhook_body: Any, channel_chat_id: Any, group_chat_id: Any, reply_message_id: Any) -> None
  _send_notifications (self: Any, channel_chat_id: Any, group_chat_id: Any, reply_message_id: Any, message_text: Any) -> None
      calls on dependencies: _telegram_gateway.send_message


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/__init__.py
================================================================================

Imports:


Global Initiations:


__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/report.py
================================================================================

Imports:
from __future__ import annotations
import urllib
import pandas as pd
from sqlalchemy import Column
from sqlalchemy import create_engine
from sqlalchemy import DateTime
from sqlalchemy import Float
from sqlalchemy import Integer
from sqlalchemy import String
from sqlalchemy import Text
from sqlalchemy import text
from sqlalchemy.dialects.postgresql import ARRAY
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from tqdm import tqdm
from jira_telegram_bot import LOGGER
from jira_telegram_bot.adapters.repositories.jira.jira_server_repository import JiraRepository
from jira_telegram_bot.settings import JIRA_SETTINGS
from jira_telegram_bot.settings import POSTGRES_SETTINGS

Global Initiations:
DB_USER = POSTGRES_SETTINGS.db_user
DB_PASSWORD = POSTGRES_SETTINGS.db_password
DB_HOST = POSTGRES_SETTINGS.db_host
DB_PORT = POSTGRES_SETTINGS.db_port
DB_NAME = POSTGRES_SETTINGS.db_name
encoded_password = urllib.parse.quote_plus(DB_PASSWORD)
DATABASE_URL = f'postgresql://{DB_USER}:{encoded_password}@{DB_HOST}:{DB_PORT}/{DB_NAME}'
engine = create_engine(DATABASE_URL)
Session = sessionmaker(bind=engine)
session = Session()
Base = declarative_base()
jira_repository = JiraRepository(settings=JIRA_SETTINGS)
__tablename__ = 'jira_tasks'
key = Column(String, primary_key=True)
summary = Column(Text, nullable=True)
description = Column(Text, nullable=True)
epic_name = Column(Text, nullable=True)
comments = Column(Text, nullable=True)
task_type = Column(String, nullable=True)
assignee = Column(String, nullable=True)
reporter = Column(String, nullable=True)
priority = Column(String, nullable=True)
status = Column(String, nullable=True)
created_at = Column(DateTime, nullable=True)
updated_at = Column(DateTime, nullable=True)
resolved_at = Column(DateTime, nullable=True)
target_start = Column(DateTime, nullable=True)
target_end = Column(DateTime, nullable=True)
story_points = Column(Float, nullable=True)
components = Column(ARRAY(String), nullable=True)
labels = Column(ARRAY(String), nullable=True)
last_sprint = Column(String, nullable=True)
sprint_repeats = Column(Integer, nullable=True)
release = Column(ARRAY(String), nullable=True)
original_estimate = Column(Text, nullable=True)
remaining_estimate = Column(Text, nullable=True)
start_at = 0
max_results = 100
issues = []
tasks_info = []
epics = {}
parschat_tasks = get_tasks_info('PARSCHAT')
pct_tasks = get_tasks_info('PCT')
all_tasks = parschat_tasks + pct_tasks
df = pd.DataFrame(all_tasks)
batch = jira_repository.jira.search_issues(f'project = {project_key}', startAt=start_at, maxResults=max_results)
comments_text = []
sprint_field = getattr(issue.fields, 'customfield_10104', None)
sprint_count = len(sprint_field) if sprint_field else 0
story_points = getattr(issue.fields, 'customfield_10106', None)
fix_versions = issue.fields.fixVersions
release_list = [fv.name for fv in fix_versions] if fix_versions else []
timetracking = getattr(issue.fields, 'timetracking', None)
task_info = {'key': issue.key, 'summary': issue.fields.summary, 'description': issue.fields.description or '', 'epic_name': epics.get(issue.fields.customfield_10100), 'comments': '\n'.join(comments_text), 'task_type': issue.fields.issuetype.name, 'assignee': issue.fields.assignee.displayName if issue.fields.assignee else None, 'reporter': issue.fields.reporter.displayName, 'priority': issue.fields.priority.name if issue.fields.priority else None, 'status': issue.fields.status.name, 'created_at': issue.fields.created, 'updated_at': issue.fields.updated, 'resolved_at': issue.fields.resolutiondate, 'target_start': getattr(issue.fields, 'customfield_10109', None), 'target_end': getattr(issue.fields, 'customfield_10110', None), 'story_points': story_points, 'components': [c.name for c in issue.fields.components] if issue.fields.components else [], 'labels': issue.fields.labels if issue.fields.labels else [], 'last_sprint': last_sprint_name, 'sprint_repeats': sprint_count, 'release': release_list, 'original_estimate': original_estimate, 'remaining_estimate': remaining_estimate}
task_obj = Task(key=t['key'], summary=t['summary'], description=t['description'], epic_name=t['epic_name'], comments=t['comments'], task_type=t['task_type'], assignee=t['assignee'], reporter=t['reporter'], priority=t['priority'], status=t['status'], created_at=t['created_at'], updated_at=t['updated_at'], resolved_at=t['resolved_at'], target_start=t['target_start'], target_end=t['target_end'], story_points=t['story_points'], components=t['components'], labels=t['labels'], last_sprint=t['last_sprint'], sprint_repeats=t['sprint_repeats'], release=t['release'], original_estimate=t['original_estimate'], remaining_estimate=t['remaining_estimate'])
sprint_str = str(sprint_field[-1])
name_start = sprint_str.find('name=') + 5
name_end = sprint_str.find(',startDate')
last_sprint_name = sprint_str[name_start:name_end]
last_sprint_name = 'Backlog'
original_estimate = getattr(timetracking, 'originalEstimate', None)
remaining_estimate = getattr(timetracking, 'remainingEstimate', None)
original_estimate = None
remaining_estimate = None
commenter = comment.author.displayName

__main__ Section:
if __name__ == '__main__':
    parschat_tasks = get_tasks_info('PARSCHAT')
    pct_tasks = get_tasks_info('PCT')
    all_tasks = parschat_tasks + pct_tasks
    df = pd.DataFrame(all_tasks)
    LOGGER.info(f'DataFrame shape: {df.shape}')
    store_tasks_in_db(all_tasks)
    LOGGER.info('Tasks have been stored (upserted) in the PostgreSQL database.')

Classes and Methods:
Class: Task


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/reports_full.py
================================================================================

Imports:
from __future__ import annotations
import re
from datetime import datetime
import pandas as pd
from tqdm import tqdm
from jira_telegram_bot import LOGGER
from jira_telegram_bot.adapters.repositories.jira.jira_server_repository import JiraRepository
from jira_telegram_bot.settings import JIRA_SETTINGS

Global Initiations:
jira_repository = JiraRepository(settings=JIRA_SETTINGS)
start_at = 0
max_results = 100
issues = []
tasks_info = []
epics = {}
sprint_df = df[df['last_sprint'].notnull()].copy()
planned_tasks = len(sprint_df)
completed_tasks = len(sprint_df[sprint_df['status'].str.lower().str.contains('done', na=False)])
sprint_completion_rate = completed_tasks / planned_tasks * 100 if planned_tasks > 0 else 0
sprint_completion_data = {'Metric': ['Planned Tasks', 'Completed Tasks', 'Completion Rate (%)'], 'Value': [planned_tasks, completed_tasks, round(sprint_completion_rate, 2)]}
sprint_completion_df = pd.DataFrame(sprint_completion_data)
task_status_breakdown = df.groupby('status')['key'].count().reset_index()
blockers_df = df[df['priority'].isin(['High', 'Highest', 'Critical']) & ~df['status'].str.lower().str.contains('done', na=False)].copy()
burn_down_data = {'Day': ['Day 1', 'Day 2', 'Day 3', 'Day 4', 'Day 5'], 'Remaining Tasks': [40, 30, 25, 10, 0]}
burn_down_df = pd.DataFrame(burn_down_data)
sprints = df['last_sprint'].dropna().unique()
completion_rows = []
completion_df = pd.DataFrame(completion_rows)
status_rows = []
status_df = pd.DataFrame(status_rows)
burndown_rows = []
burndown_df = pd.DataFrame(burndown_rows)
done_df = df[df['status'].str.lower().str.contains('done', na=False) & df['resolved_at'].notnull()].copy()
avg_completion_time = done_df['completion_days'].mean() if not done_df.empty else 0
avg_completion_data = {'Metric': ['Average Task Completion Time (days)'], 'Value': [round(avg_completion_time, 2)]}
avg_completion_df = pd.DataFrame(avg_completion_data)
workload_df = df.groupby('assignee')['key'].count().reset_index()
bug_count = len(df[df['task_type'].str.lower() == 'bug'])
feature_count = len(df[df['task_type'].str.lower().isin(['story', 'task'])])
bug_vs_feature = {'Type': ['Bug', 'Feature'], 'Count': [bug_count, feature_count]}
bug_vs_feature_df = pd.DataFrame(bug_vs_feature)
tasks = get_tasks_info()
df = pd.DataFrame(tasks)
datetime_columns = ['created_at', 'updated_at', 'resolved_at', 'target_start', 'target_end']
sprint_progress_data = create_sprint_progress_dashboard(df)
sprint_progress_per_sprint = create_sprint_progress_dashboard_by_sprint(df)
team_productivity_data = create_team_productivity_workload_dashboard(df)
df = sanitize_dataframe(df)
current_date = datetime.now().strftime('%Y-%m-%d')
filename = f'jira_tasks_{current_date}.xlsx'
batch = jira_repository.jira.search_issues('project = PARSCHAT', startAt=start_at, maxResults=max_results)
comments_text = []
sprint_field = getattr(issue.fields, 'customfield_10104', None)
story_points = getattr(issue.fields, 'customfield_10106', None)
task_info = {'key': issue.key, 'summary': issue.fields.summary, 'description': issue.fields.description or '', 'epic_name': epics.get(issue.fields.customfield_10100), 'comments': '\n'.join(comments_text), 'task_type': issue.fields.issuetype.name, 'assignee': issue.fields.assignee.displayName if issue.fields.assignee else None, 'reporter': issue.fields.reporter.displayName if issue.fields.reporter else None, 'priority': issue.fields.priority.name if issue.fields.priority else None, 'status': issue.fields.status.name, 'created_at': issue.fields.created, 'updated_at': issue.fields.updated, 'resolved_at': issue.fields.resolutiondate, 'target_start': getattr(issue.fields, 'customfield_10109', None), 'target_end': getattr(issue.fields, 'customfield_10110', None), 'story_points': story_points, 'components': '{' + ','.join([c.name for c in issue.fields.components]) + '}' if issue.fields.components else '{}', 'labels': '{' + ','.join(issue.fields.labels) + '}' if issue.fields.labels else '{}', 'last_sprint': last_sprint_name, 'sprint_repeats': sprint_count}
sprint_tasks = df[df['last_sprint'] == sprint]
planned = len(sprint_tasks)
completed = len(sprint_tasks[sprint_tasks['status'].str.lower().str.contains('done', na=False)])
rate = completed / planned * 100 if planned else 0
sprint_tasks = df[df['last_sprint'] == sprint]
grouped = sprint_tasks.groupby('status')['key'].count()
sprint_str = str(sprint_field[-1])
name_start = sprint_str.find('name=') + 5
name_end = sprint_str.find(',startDate')
last_sprint_name = sprint_str[name_start:name_end]
sprint_count = len(sprint_field)
last_sprint_name = None
sprint_count = 0
commenter = comment.author.displayName

__main__ Section:
if __name__ == '__main__':
    main()

Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/create_task_usecase.py
================================================================================

Imports:
from __future__ import annotations
from typing import List
from typing import Optional
from jira_telegram_bot.entities.task import TaskData
from jira_telegram_bot.use_cases.interface.task_manager_repository_interface import TaskManagerRepositoryInterface

Global Initiations:
data = TaskData(project_key=project_key, summary=summary, description=description, task_type=task_type, labels=labels or [], assignee=assignee)
issue = self._jira_repo.create_task(data)

__main__ Section:


Classes and Methods:
Class: CreateTaskUseCase
  __init__ (self: Any, jira_repo: TaskManagerRepositoryInterface) -> None
  run (self: Any, project_key: str, summary: str, description: str, task_type: str, labels: Optional[List[str]], assignee: Optional[str]) -> None
      calls on dependencies: _jira_repo.create_task


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/utils/___init__.py
================================================================================

Imports:


Global Initiations:


__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/utils/data_store.py
================================================================================

Imports:
from __future__ import annotations
import json
import os
from typing import Any
from typing import Dict
from typing import Optional
from jira_telegram_bot import DEFAULT_PATH

Global Initiations:
DATA_STORE_PATH = f'{DEFAULT_PATH}/data_store.json'
data = load_data_store()
data = load_data_store()
data = load_data_store()
data_store = load_data_store()
data = load_data_store()

__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/utils/check_version.py
================================================================================

Imports:
from __future__ import annotations
import logging
import os
import re
import subprocess
import sys
from pathlib import Path

Global Initiations:
DEFAULT_PATH = Path(os.path.realpath(__file__)).parents[2]
LOGGER = logging.getLogger(__name__)
console_handler = logging.StreamHandler()
version_file_path = os.path.join(f'{DEFAULT_PATH}/jira_telegram_bot', '__init__.py')
current_version = get_current_version(version_file_path)
previous_version = get_previous_version(version_file_path)
result = subprocess.run(['git', 'log', '-p', '-n 1', file_path], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
diff_content = result.stdout
match = re.search('\\+__version__\\s*=\\s*["\\\']([^"\\\']+)["\\\']', diff_content)
match = re.search('__version__\\s*=\\s*["\\\']([^"\\\']+)["\\\']', content)
result = subprocess.run(['git', 'diff', file_path], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
diff_output = result.stdout
content = f.read()

__main__ Section:
if __name__ == '__main__':
    if main() == 1:
        sys.exit(0)
    else:
        sys.exit(1)

Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/utils/speech_utils.py
================================================================================

Imports:
from __future__ import annotations
import os
import openai
from loguru import logger
from pydub import AudioSegment
from jira_telegram_bot.settings import OPENAI_SETTINGS

Global Initiations:
wav_path = ogg_path + '.wav'
persian_chars = len([c for c in text if '\u0600' <= c <= 'ۿ'])
audio = AudioSegment.from_ogg(ogg_path)
text = await self.transcribe_audio(wav_path)
response = await openai.ChatCompletion.acreate(model='gpt-4', messages=[{'role': 'system', 'content': 'You are a Persian to English translator.\n                                   Translate the following text accurately while preserving technical terms:'}, {'role': 'user', 'content': text}], temperature=0.3)
transcription = await openai.Audio.atranscribe('whisper-1', audio_file)
wav_path = await self.convert_ogg_to_wav(voice_file_path)
wav_path = voice_file_path

__main__ Section:


Classes and Methods:
Class: SpeechProcessor
  __init__ (self: Any) -> None
  convert_ogg_to_wav (self: Any, ogg_path: str) -> str
  transcribe_audio (self: Any, audio_path: str) -> str
  process_voice_message (self: Any, voice_file_path: str) -> str
  is_persian (text: str) -> bool
  translate_to_english (self: Any, text: str) -> str


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/utils/pydantic_advanced_settings.py
================================================================================

Imports:
import json
import argparse
from pathlib import Path
from typing import Any, Dict, Tuple, Type
from pydantic.fields import FieldInfo
from pydantic_settings import BaseSettings, PydanticBaseSettingsSource

Global Initiations:
parser = argparse.ArgumentParser(description='Command line arguments')
field_value = getattr(self.args, field_name, None)
encoding = self.config.get('env_file_encoding')
file_content_json = json.loads(Path('config.json').read_text(encoding))
field_value = file_content_json.get(field_name)
json_file_path = Path('config.json')
field_value = getattr(self.args, field_name, None)
field_value = self.prepare_field_value(field_name, field, field_value, value_is_complex)

__main__ Section:


Classes and Methods:
Class: ArgparseConfigSettingsSource
  __init__ (self: Any, settings_cls: Type[BaseSettings]) -> None
  _parse_args (self: Any) -> None
  get_field_value (self: Any, field: FieldInfo, field_name: str) -> Tuple[Any, str, bool]
  __call__ (self: Any) -> Dict[str, Any]
Class: JsonConfigSettingsSource
  get_field_value (self: Any, field: FieldInfo, field_name: str) -> Tuple[Any, str, bool]
  prepare_field_value (self: Any, field_name: str, field: FieldInfo, value: Any, value_is_complex: bool) -> Any
  __call__ (self: Any) -> Dict[str, Any]
Class: CustomizedSettings
  settings_customise_sources (cls: Any, settings_cls: Type[BaseSettings], init_settings: PydanticBaseSettingsSource, env_settings: PydanticBaseSettingsSource, dotenv_settings: PydanticBaseSettingsSource, file_secret_settings: PydanticBaseSettingsSource) -> Tuple[PydanticBaseSettingsSource, ...]


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/utils/markdown_cleaner.py
================================================================================

Imports:
import ast
import re
import textwrap

Global Initiations:
_quote_pat = re.compile('^([\\\'"]{3})(.*)(\\1)$', flags=re.S)
x = '\n\n\n\n'
triple = _quote_pat.match(s)
s = raw.strip()
s = s.replace('\r\n', '\n').replace('\r', '\n')
s = raw.strip()
replacements = {'\\n': '\n', '\\t': '\t', "\\'": "'", '\\"': '"'}
s = re.sub('\\\\n|\\\\t|\\\\\\\'|\\\\"', _sub, s)
s = s.replace('\r\n', '\n').replace('\r', '\n')
raw_input = '\'As a User, I want to easily connect ParsChat to my website via a JavaScript snippet so that I can quickly integrate ParsChat\'s features and improve user engagement on my site.\n\nThis story directly supports the \'Improve user experience\' OKR by simplifying the integration process for new users. A streamlined connection process encourages adoption and allows users to quickly realize the benefits of ParsChat, leading to a better overall experience. By providing a simple JavaScript snippet, we reduce friction and empower users to seamlessly integrate ParsChat into their existing workflows.\n\nAcceptance Criteria:\n\n* Given I am on the Service Connection page in the ParsChat panel\n When I navigate to the Widget service connection section\n Then I should see a clearly labeled section for obtaining the JavaScript snippet.\n\n* Given I am on the Widget service connection section\n When I click the "Copy Snippet" button\n Then the JavaScript snippet should be copied to my clipboard.\n\n* Given I have pasted the JavaScript snippet into my website\'s HTML\n When a user visits my website\n Then the ParsChat widget should be visible and functional.\n\n* Given the user enters an invalid chat page or plugin page\n When the JavaScript snippet is pasted into the website\'s HTML\n Then the ParsChat widget should not be visible and functional.\n\nNon-functional Requirements:\n\n* Performance: The JavaScript snippet should load asynchronously and not negatively impact the website\'s loading time.\n* Security: The snippet should be secure and not introduce any vulnerabilities to the user\'s website.\n* Compatibility: The snippet should be compatible with all major web browsers (Chrome, Firefox, Safari, Edge).\n* Accessibility: The widget should be accessible to users with disabilities, following WCAG guidelines.\n\nSizing:\n\n* Story Points: 5. Rationale: This involves front-end development, UI changes, and testing. It\'s more complex than a simple task but less complex than a large feature.\n\nRisks & Open Questions:\n\n* What are the specific browser compatibility requirements?\n* How will we handle potential conflicts with existing JavaScript libraries on the user\'s website?\n* What error handling and logging mechanisms should be implemented in the snippet?\n\nDefinition of Done:\n\n* Code: JavaScript snippet generation logic is implemented and reviewed.\n* Tests: Unit and integration tests are written and passing, covering all acceptance criteria.\n* Documentation: User documentation is updated with instructions on how to use the JavaScript snippet.\n* Release Validation: The JavaScript snippet is tested on a staging environment and verified to work as expected before release.\''
cleaned_output = clean_ai_markdown(raw_input)
cl2 = clean_ai_markdown_2(raw_input)
old = s
s = _strip_one_quote_layer(s)
s = _decode_once(s)
s = s[1:-1]

__main__ Section:
if __name__ == '__main__':
    raw_input = '\'As a User, I want to easily connect ParsChat to my website via a JavaScript snippet so that I can quickly integrate ParsChat\'s features and improve user engagement on my site.\n\nThis story directly supports the \'Improve user experience\' OKR by simplifying the integration process for new users. A streamlined connection process encourages adoption and allows users to quickly realize the benefits of ParsChat, leading to a better overall experience. By providing a simple JavaScript snippet, we reduce friction and empower users to seamlessly integrate ParsChat into their existing workflows.\n\nAcceptance Criteria:\n\n* Given I am on the Service Connection page in the ParsChat panel\n When I navigate to the Widget service connection section\n Then I should see a clearly labeled section for obtaining the JavaScript snippet.\n\n* Given I am on the Widget service connection section\n When I click the "Copy Snippet" button\n Then the JavaScript snippet should be copied to my clipboard.\n\n* Given I have pasted the JavaScript snippet into my website\'s HTML\n When a user visits my website\n Then the ParsChat widget should be visible and functional.\n\n* Given the user enters an invalid chat page or plugin page\n When the JavaScript snippet is pasted into the website\'s HTML\n Then the ParsChat widget should not be visible and functional.\n\nNon-functional Requirements:\n\n* Performance: The JavaScript snippet should load asynchronously and not negatively impact the website\'s loading time.\n* Security: The snippet should be secure and not introduce any vulnerabilities to the user\'s website.\n* Compatibility: The snippet should be compatible with all major web browsers (Chrome, Firefox, Safari, Edge).\n* Accessibility: The widget should be accessible to users with disabilities, following WCAG guidelines.\n\nSizing:\n\n* Story Points: 5. Rationale: This involves front-end development, UI changes, and testing. It\'s more complex than a simple task but less complex than a large feature.\n\nRisks & Open Questions:\n\n* What are the specific browser compatibility requirements?\n* How will we handle potential conflicts with existing JavaScript libraries on the user\'s website?\n* What error handling and logging mechanisms should be implemented in the snippet?\n\nDefinition of Done:\n\n* Code: JavaScript snippet generation logic is implemented and reviewed.\n* Tests: Unit and integration tests are written and passing, covering all acceptance criteria.\n* Documentation: User documentation is updated with instructions on how to use the JavaScript snippet.\n* Release Validation: The JavaScript snippet is tested on a staging environment and verified to work as expected before release.\''
    cleaned_output = clean_ai_markdown(raw_input)
    print(cleaned_output)

    def show(raw):
        print('repr()  -->', repr(raw))
        print('length -->', len(raw), 'characters\n')
    show(cleaned_output)
    cl2 = clean_ai_markdown_2(raw_input)
    print(cl2)
    show(cl2)

Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/utils/basic_logger.py
================================================================================

Imports:
import os
import sys
import logging
from loguru import logger

Global Initiations:
__all__ = ('simple_logger', 'loguru_logger')
green = '\x1b[32m'
grey = '\x1b[36m'
blue = '\x1b[38;5;39m'
yellow = '\x1b[38;5;226m'
red = '\x1b[38;5;196m'
bold_red = '\x1b[31;1m'
reset = '\x1b[0m'
splitter = get_splitter_format()
logger = logging.getLogger(name)
file_format = '%(levelname)s-%(asctime)s-FILENAME:%(filename)s-MODULE:%(module)s-%(lineno)d-FUNC:%(funcName)s-THREAD:%(threadName)s :: %(message)s'
console_format = '%(levelname)s-%(asctime)s-FILENAME:%(filename)s-MODULE:%(module)s-%(lineno)d-FUNC:%(funcName)s-THREAD:%(threadName)s :: %(message)s'
file_formatter = logging.Formatter(file_format, datefmt='%Y-%m-%d %H:%M:%S')
console_formatter = ColoredFormatter(console_format, datefmt='%Y-%m-%d %H:%M:%S')
console_handler = logging.StreamHandler()
console_format = '<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level}</level> | FILENAME: <cyan>{file}</cyan> - MODULE: <cyan>{module}</cyan> - FUNC: <cyan>{function}</cyan> - LINE: <cyan>{line}</cyan> - THREAD: <cyan>{thread.name}</cyan> :: <level>{message}</level>'
idx = sys.argv.index('--stream_level')
idx = eval(os.environ['stream_level'])
file_handler = logging.FileHandler(filename=filename)
idx = sys.argv.index('--stream_level')
stream_level = os.environ['stream_level']
file_format = '{time:YYYY-MM-DD HH:mm:ss} | {level} | FILENAME: {file} - MODULE: {module} - FUNC: {function} - LINE: {line} - THREAD: {thread.name} :: {message}\n' + '-' * 100
stream_level = eval(sys.argv[idx + 1])
stream_level = sys.argv[idx + 1]

__main__ Section:


Classes and Methods:
Class: ColoredFormatter
  __init__ (self: Any) -> None
  format (self: Any, record: logging.LogRecord) -> str


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/utils/jalali_georgian_calendar.py
================================================================================

Imports:
from __future__ import annotations
from dataclasses import dataclass
from typing import Any
from typing import Dict
from typing import List
from typing import Optional

Global Initiations:
day = self._by_jalali.get(jalali_day)
day = self._by_gregorian.get(gregorian_day)
d = self._by_gregorian.get(gregorian_day)
d = self._by_jalali.get(jalali_day)

__main__ Section:


Classes and Methods:
Class: Day
  j (self: Any) -> int
  g (self: Any) -> int
Class: JalaliGregorianCalendar
  __init__ (self: Any, month_json: Dict[str, Any]) -> None
  _parse (day_json: Dict[str, Any]) -> Day
  gregorian_from_jalali (self: Any, jalali_day: int) -> Optional[int]
  jalali_from_gregorian (self: Any, gregorian_day: int) -> Optional[int]
  weekend_days (self: Any) -> List[Day]
  holidays (self: Any) -> List[Day]
  is_holiday_gregorian (self: Any, gregorian_day: int) -> bool
  is_holiday_jalali (self: Any, jalali_day: int) -> bool
  __repr__ (self: Any) -> str


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/adapters/google_sheet.py
================================================================================

Imports:
from __future__ import annotations
import asyncio
import unittest
from abc import ABC
from abc import abstractmethod
from typing import Any
from typing import Dict
from typing import List
from typing import Optional
import gspread
from oauth2client.service_account import ServiceAccountCredentials
from jira_telegram_bot import LOGGER
from jira_telegram_bot.adapters.repositories.jira.jira_server_repository import JiraRepository
from jira_telegram_bot.entities.task import TaskData
from jira_telegram_bot.settings import GOOGLE_SHEETS_SETTINGS
from jira_telegram_bot.settings import JIRA_SETTINGS

Global Initiations:
assignments = self.get_assignment_records(sheet_id, worksheet_name)
created_issues = []
task_data = TaskData(project_key=project_key or assignment.get('Project'), summary=assignment.get('Summary', ''), description=assignment.get('Description', ''), components=self._split_comma_separated(assignment.get('Component', '')), task_type=assignment.get('Type', default_task_type), story_points=float(assignment.get('Story Points', 0)) if assignment.get('Story Points') else None, assignee=assignment.get('Assignee'), priority=assignment.get('Priority'), epic_link=assignment.get('Epic'), labels=self._split_comma_separated(assignment.get('Labels', '')))
board_id = jira_repository.get_board_id(task_data.project_key)
dummy_client = DummySheetClient()
repository = SheetRepository(dummy_client)
records = repository.get_sheet_records('dummy_sheet_id')
expected = [{'Name': 'Alice', 'Age': 30}, {'Name': 'Bob', 'Age': 25}]
jira_repository = JiraRepository(JIRA_SETTINGS)
sheet_client = GoogleSheetClient(GOOGLE_SHEETS_SETTINGS.token_path)
repository = SheetRepository(sheet_client)
created_issues = repository.create_jira_tasks_from_assignments(sheet_id=GOOGLE_SHEETS_SETTINGS.sheet_id, jira_repository=jira_repository, worksheet_name=GOOGLE_SHEETS_SETTINGS.worksheet_name, project_key=None)
sheet_client = GoogleSheetClient(GOOGLE_SHEETS_SETTINGS.token_path)
repository = SheetRepository(sheet_client)
records = repository.get_sheet_records(GOOGLE_SHEETS_SETTINGS.sheet_id)
scope = ['https://spreadsheets.google.com/feeds', 'https://www.googleapis.com/auth/spreadsheets', 'https://www.googleapis.com/auth/drive.file', 'https://www.googleapis.com/auth/drive']
spreadsheet = self.client.open_by_key(sheet_id)
spreadsheet = self.client.open_by_key(sheet_id)
worksheet = self.sheet_client.get_worksheet(sheet_id, worksheet_index)
records = worksheet.get_all_records()
records = worksheet.get_all_records()
task_data = self._create_task_data(assignment, project_key, default_task_type)
sprints = jira_repository.get_sprints(board_id)
worksheet = self.sheet_client.get_worksheet_by_name(sheet_id, worksheet_name)
spreadsheet = self.sheet_client.client.open_by_key(sheet_id)
worksheet = spreadsheet.worksheet(worksheet_name)
issue = jira_repository.create_task(task_data)

__main__ Section:
if __name__ == '__main__':
    main()

Classes and Methods:
Class: ISheetClient
  get_worksheet (self: Any, sheet_id: str, worksheet_index: int) -> None
  get_worksheet_by_name (self: Any, sheet_id: str, worksheet_name: str) -> None
Class: GoogleSheetClient
  __init__ (self: Any, json_token_path: str, scope: List[str]) -> None
  get_worksheet (self: Any, sheet_id: str, worksheet_index: int) -> None
      calls on dependencies: client.open_by_key
  get_worksheet_by_name (self: Any, sheet_id: str, worksheet_name: str) -> None
      calls on dependencies: client.open_by_key
Class: SheetRepository
  __init__ (self: Any, sheet_client: ISheetClient) -> None
  get_sheet_records (self: Any, sheet_id: str, worksheet_index: int) -> List[Dict[str, Any]]
      calls on dependencies: sheet_client.get_worksheet
  get_assignment_records (self: Any, sheet_id: str, worksheet_name: str) -> List[Dict[str, Any]]
      calls on dependencies: sheet_client.client.open_by_key, sheet_client.get_worksheet_by_name
  create_jira_tasks_from_assignments (self: Any, sheet_id: str, jira_repository: JiraRepository, worksheet_name: str, project_key: Optional[str], default_task_type: str) -> List[str]
  _create_task_data (self: Any, assignment: Dict[str, Any], project_key: Optional[str], default_task_type: str) -> TaskData
  _set_sprint_for_task (self: Any, task_data: TaskData, jira_repository: JiraRepository, sprint_name: str) -> None
  _split_comma_separated (self: Any, value: str) -> List[str]
Class: DummyWorksheet
  get_all_records (self: Any) -> None
Class: DummySheetClient
  get_worksheet (self: Any, sheet_id: str, worksheet_index: int) -> None
  get_worksheet_by_name (self: Any, sheet_id: str, worksheet_name: str) -> None
  client (self: Any) -> None
Class: TestSheetRepository
  test_get_sheet_records (self: Any) -> None


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/adapters/user_config.py
================================================================================

Imports:
from __future__ import annotations
import json
from typing import Optional
from pydantic import ValidationError
from jira_telegram_bot import DEFAULT_PATH
from jira_telegram_bot import LOGGER
from jira_telegram_bot.entities.user_config import UserConfig as UserConfigEntity
from jira_telegram_bot.use_cases.interface.user_config_interface import UserConfigInterface

Global Initiations:
USER_CONFIG_PATH = f'{DEFAULT_PATH}/jira_telegram_bot/settings/user_config.json'
user_configurations = {}
configs = {username: user_cfg.dict() for username, user_cfg in self.user_config.items()}
raw_data = json.load(file)

__main__ Section:


Classes and Methods:
Class: UserConfig
  __init__ (self: Any, user_config_path: str) -> None
  load_user_config (self: Any, user_config_path: str) -> None
  get_user_config (self: Any, username: str) -> Optional[UserConfigEntity]
  list_all_users (self: Any) -> None
  get_user_config_by_jira_username (self: Any, jira_username: str) -> Optional[UserConfigEntity]
  save_user_config (self: Any, telegram_username: str, user_cfg: UserConfig) -> None


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/adapters/batch_task_creation.py
================================================================================

Imports:
from __future__ import annotations
from jira_telegram_bot import LOGGER
from jira_telegram_bot.adapters.repositories.jira.jira_server_repository import JiraRepository
from jira_telegram_bot.entities.task import TaskData
from jira_telegram_bot.settings import JIRA_SETTINGS

Global Initiations:
jira_repository = JiraRepository(JIRA_SETTINGS)
tasks = [{'summary': 'بازطراحی دیالوگ\u200cهای تأیید (مانند حذف ربات)', 'description': 'طراحی جدید برای پنجره\u200cهای پاپ\u200cآپ تأیید عملیات با تأکید بر وضوح پیام، هماهنگی رنگ و ابعاد، و بهبود تجربه کاربری برای عملیات حساس نظیر حذف ربات.'}, {'summary': 'بازطراحی صفحه اشتراک\u200cها', 'description': 'بازنگری UI/UX صفحه پلن\u200cهای اشتراک با افزودن لینک ویدیو معرفی، برجسته\u200cسازی گزینه پشتیبانی رایگان و اضافه کردن بخشی برای نمایش تعداد صفحات PDF و لینک به اطلاعات حساب کاربری.'}]
tasks = [{**task, 'assignee': 'xx', 'project_key': 'PARxxCHAT', 'component': 'UI / UX', 'task_type': 'Task'} for task in tasks]
issue = jira_repository.create_task(TaskData(**task))

__main__ Section:
if __name__ == '__main__':
    jira_repository = JiraRepository(JIRA_SETTINGS)
    tasks = [{'summary': 'بازطراحی دیالوگ\u200cهای تأیید (مانند حذف ربات)', 'description': 'طراحی جدید برای پنجره\u200cهای پاپ\u200cآپ تأیید عملیات با تأکید بر وضوح پیام، هماهنگی رنگ و ابعاد، و بهبود تجربه کاربری برای عملیات حساس نظیر حذف ربات.'}, {'summary': 'بازطراحی صفحه اشتراک\u200cها', 'description': 'بازنگری UI/UX صفحه پلن\u200cهای اشتراک با افزودن لینک ویدیو معرفی، برجسته\u200cسازی گزینه پشتیبانی رایگان و اضافه کردن بخشی برای نمایش تعداد صفحات PDF و لینک به اطلاعات حساب کاربری.'}]
    tasks = [{**task, 'assignee': 'xx', 'project_key': 'PARxxCHAT', 'component': 'UI / UX', 'task_type': 'Task'} for task in tasks]
    batch_task_creation(jira_repository, tasks)

Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/adapters/__init__.py
================================================================================

Imports:


Global Initiations:


__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/adapters/deadline_notifier.py
================================================================================

Imports:
from __future__ import annotations
from datetime import datetime
from datetime import timedelta
import requests
from jira_telegram_bot import LOGGER
from jira_telegram_bot.adapters.repositories.jira.jira_server_repository import JiraRepository
from jira_telegram_bot.adapters.user_config import UserConfig
from jira_telegram_bot.settings import JIRA_SETTINGS
from jira_telegram_bot.settings import TELEGRAM_SETTINGS

Global Initiations:
due_date_str = getattr(issue.fields, 'duedate', None)
sprint_field = getattr(issue.fields, 'customfield_10104', None)
tasks_by_date = {}
lines = []
sorted_dates = sorted((d for d in tasks_by_date.keys() if d != 'بدون مهلت'))
url = f'https://api.telegram.org/bot{TELEGRAM_SETTINGS.TOKEN}/sendMessage'
payload = {'chat_id': chat_id, 'text': text, 'parse_mode': 'Markdown', 'disable_web_page_preview': True}
jira_repo = JiraRepository(settings=JIRA_SETTINGS)
user_config = UserConfig()
threshold_date = datetime.now() + timedelta(days=3)
all_users = user_config.list_all_users()
deadline = get_effective_deadline(issue)
resp = requests.post(url, json=payload, timeout=10)
cfg = user_config.get_user_config(username)
jql = f'assignee="{cfg.jira_username}" AND statusCategory != Done order by duedate ASC'
issues = jira_repo.jira.search_issues(jql, maxResults=200)
due_soon = []
tasks_by_date = categorize_tasks_by_deadline(due_soon)
message_text = build_message(tasks_by_date)
sprint_str = str(sprint_info)
date_str = 'بدون مهلت'
date_str = deadline.strftime('%Y-%m-%d')
key = issue.key
summary = issue.fields.summary
link = f'{JIRA_SETTINGS.domain}/browse/{key}'
eff_deadline = get_effective_deadline(issue)
end_part = sprint_str.split('endDate=')[1].split(',')[0]

__main__ Section:
if __name__ == '__main__':
    main()

Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/adapters/fetch_store_gitlab_commits.py
================================================================================

Imports:
from __future__ import annotations
import re
import urllib.parse
from datetime import datetime
from datetime import timedelta
import gitlab
from sqlalchemy import Boolean
from sqlalchemy import Column
from sqlalchemy import create_engine
from sqlalchemy import DateTime
from sqlalchemy import Integer
from sqlalchemy import String
from sqlalchemy import Text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from tqdm import tqdm
from jira_telegram_bot import LOGGER
from jira_telegram_bot.settings import GITLAB_SETTINGS
from jira_telegram_bot.settings import POSTGRES_SETTINGS

Global Initiations:
Base = declarative_base()
pattern = '^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\\(\\S+\\))?: .{1,}'
__tablename__ = 'git_commit'
commit_id = Column(String, primary_key=True)
repository = Column(String, nullable=False)
committer_email = Column(String, nullable=False)
committer_name = Column(String, nullable=True)
commit_time = Column(DateTime, nullable=False)
message = Column(Text, nullable=True)
is_conventional = Column(Boolean, default=False)
python_lines_changed = Column(Integer, default=0)
lines_added = Column(Integer, default=0)
lines_removed = Column(Integer, default=0)
pg_settings = POSTGRES_SETTINGS
encoded_password = urllib.parse.quote_plus(pg_settings.db_password)
database_url = f'postgresql://{pg_settings.db_user}:{encoded_password}@{pg_settings.db_host}:{pg_settings.db_port}/{pg_settings.db_name}'
engine = create_engine(database_url)
Session = sessionmaker(bind=engine)
python_lines_changed = 0
session = create_db_session()
gl_settings = GITLAB_SETTINGS
gl = gitlab.Gitlab(url=gl_settings.url, private_token=gl_settings.access_token)
three_months_ago = datetime.utcnow() - timedelta(days=1)
projects = gl.projects.list(all=True)
diffs = commit_obj.diff(get_all=True)
new_path = diff_item.get('new_path', '')
project_name = project.name
commits = project.commits.list(all=True, query_parameters={'since': three_months_ago.isoformat()})
diff_text = diff_item.get('diff', '')
lines = diff_text.split('\n')
commit_id = c.id
commit_time = datetime.fromisoformat(c.created_at)
message = c.message
email = c.author_email
name = c.author_name
conventional = is_conventional_commit(message)
full_commit = project.commits.get(c.id)
c_stats = full_commit.stats or {}
lines_added = c_stats.get('additions', 0)
lines_removed = c_stats.get('deletions', 0)
python_lines_changed = calculate_python_lines_changed(c)
git_commit_record = GitCommit(commit_id=commit_id, repository=project_name, committer_email=email, committer_name=name, commit_time=commit_time, message=message, is_conventional=conventional, python_lines_changed=python_lines_changed, lines_added=lines_added, lines_removed=lines_removed)

__main__ Section:
if __name__ == '__main__':
    fetch_and_store_commits()

Classes and Methods:
Class: GitCommit


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/settings/jira_board_config.py
================================================================================

Imports:
from __future__ import annotations
from typing import List
from pydantic import Field
from pydantic_settings import BaseSettings
from pydantic_settings import SettingsConfigDict

Global Initiations:
model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8', env_prefix='jira_board_', extra='ignore')

__main__ Section:


Classes and Methods:
Class: JiraBoardSettings


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/settings/gemini_settings.py
================================================================================

Imports:
from __future__ import annotations
from pydantic_settings import BaseSettings
from pydantic_settings import SettingsConfigDict

Global Initiations:
model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8', env_prefix='gemini_connection_config_', extra='ignore')

__main__ Section:


Classes and Methods:
Class: GeminiConnectionSetting


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/settings/jira_settings.py
================================================================================

Imports:
from pydantic_settings import SettingsConfigDict
from pydantic import Field
from jira_telegram_bot.utils.pydantic_advanced_settings import CustomizedSettings

Global Initiations:
model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8', env_prefix='jira_', extra='ignore')

__main__ Section:


Classes and Methods:
Class: JiraConnectionSettings


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/settings/openai_settings.py
================================================================================

Imports:
from __future__ import annotations
from pydantic import Field
from pydantic_settings import SettingsConfigDict
from jira_telegram_bot.utils.pydantic_advanced_settings import CustomizedSettings

Global Initiations:
model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8', env_prefix='openai_', extra='ignore')

__main__ Section:


Classes and Methods:
Class: OpenAISettings


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/settings/postgre_db_settings.py
================================================================================

Imports:
from __future__ import annotations
from pydantic import Field
from pydantic_settings import BaseSettings
from pydantic_settings import SettingsConfigDict

Global Initiations:
model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8', extra='ignore')

__main__ Section:


Classes and Methods:
Class: PostgresSettings


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/settings/__init__.py
================================================================================

Imports:
from __future__ import annotations
from jira_telegram_bot import DEFAULT_PATH
from jira_telegram_bot.settings.gemini_settings import GeminiConnectionSetting
from jira_telegram_bot.settings.gitlab_settings import GitlabSettings
from jira_telegram_bot.settings.jira_board_config import JiraBoardSettings
from jira_telegram_bot.settings.jira_settings import JiraConnectionSettings
from jira_telegram_bot.settings.openai_settings import OpenAISettings
from jira_telegram_bot.settings.postgre_db_settings import PostgresSettings
from jira_telegram_bot.settings.telegram_settings import TelegramConnectionSettings
from jira_telegram_bot.settings.telegram_settings import TelegramWebhookConnectionSettings

Global Initiations:
JIRA_SETTINGS = JiraConnectionSettings(_env=f'{DEFAULT_PATH}/.env')
JIRA_BOARD_SETTINGS = JiraBoardSettings(_env=f'{DEFAULT_PATH}/.env')
TELEGRAM_SETTINGS = TelegramConnectionSettings(_env=f'{DEFAULT_PATH}/.env')
OPENAI_SETTINGS = OpenAISettings(_env=f'{DEFAULT_PATH}/.env')
TELEGRAM_WEBHOOK_SETTINGS = TelegramWebhookConnectionSettings(_env=f'{DEFAULT_PATH}/.env')
GITLAB_SETTINGS = GitlabSettings(_env=f'{DEFAULT_PATH}/.env')
POSTGRES_SETTINGS = PostgresSettings(_env=f'{DEFAULT_PATH}/.env')
GEMINI_SETTINGS = GeminiConnectionSetting(_env=f'{DEFAULT_PATH}/.env')

__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/settings/google_sheets_settings.py
================================================================================

Imports:
from __future__ import annotations
from pydantic import Field
from pydantic_settings import SettingsConfigDict
from jira_telegram_bot.utils.pydantic_advanced_settings import CustomizedSettings

Global Initiations:
model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8', env_prefix='google_sheets_', extra='ignore')

__main__ Section:


Classes and Methods:
Class: GoogleSheetsConnectionSettings


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/settings/telegram_settings.py
================================================================================

Imports:
from __future__ import annotations
from typing import List
from pydantic import Field
from pydantic_settings import BaseSettings
from pydantic_settings import SettingsConfigDict

Global Initiations:
model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8', env_prefix='TELEGRAM_', extra='ignore')
model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8', env_prefix='TELEGRAM_HOOK_', extra='ignore')

__main__ Section:


Classes and Methods:
Class: TelegramConnectionSettings
Class: TelegramWebhookConnectionSettings


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/settings/gitlab_settings.py
================================================================================

Imports:
from __future__ import annotations
from pydantic import Field
from pydantic_settings import BaseSettings
from pydantic_settings import SettingsConfigDict

Global Initiations:
model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8', env_prefix='gitlab_', extra='ignore')

__main__ Section:


Classes and Methods:
Class: GitlabSettings


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/frameworks/__init__.py
================================================================================

Imports:


Global Initiations:


__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/interface/summary_generator_interface.py
================================================================================

Imports:
from __future__ import annotations
from typing import Dict
from typing import List
from jira_telegram_bot.entities.task import TaskData

Global Initiations:


__main__ Section:


Classes and Methods:
Class: ISummaryGenerator
  generate_summary (self: Any, grouped_tasks: Dict[str, Dict[str, List[TaskData]]]) -> str


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/interface/openai_gateway_interface.py
================================================================================

Imports:
from __future__ import annotations
from abc import ABC
from abc import abstractmethod
from langchain_openai import ChatOpenAI

Global Initiations:


__main__ Section:


Classes and Methods:
Class: OpenAIGatewayInterface
  get_llm (self: Any) -> ChatOpenAI


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/interface/task_manager_repository_interface.py
================================================================================

Imports:
from __future__ import annotations
from abc import ABC
from abc import abstractmethod
from typing import Dict
from typing import List
from typing import Optional
from jira import Issue
from jira_telegram_bot.entities.task import TaskData

Global Initiations:


__main__ Section:


Classes and Methods:
Class: TaskManagerRepositoryInterface
  get_projects (self: Any) -> None
  get_project_components (self: Any, project_key: Any) -> None
  get_epics (self: Any, project_key: str) -> None
  get_board_id (self: Any, project_key: str) -> Optional[int]
  get_sprints (self: Any, board_id: Any) -> None
  get_project_versions (self: Any, project_key: Any) -> None
  get_issue_types_for_project (self: Any, project_key: Any) -> None
  get_priorities (self: Any) -> None
  get_assignees (self: Any, project_key: str) -> List[str]
  search_users (self: Any, username: str) -> List[str]
  build_issue_fields (self: Any, task_data: TaskData) -> dict
  handle_attachments (self: Any, issue: Issue, attachments: Dict[str, List]) -> None
  create_issue (self: Any, fields: Any) -> None
  add_attachment (self: Any, issue: Any, attachment: Any, filename: Any) -> None
  create_task (self: Any, task_data: TaskData) -> Issue
  update_issue (self: Any, task_data: TaskData) -> Issue
  get_issue (self: Any, task_id: str) -> Optional[Issue]


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/interface/__init__.py
================================================================================

Imports:


Global Initiations:


__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/interface/speech_processor_interface.py
================================================================================

Imports:
from __future__ import annotations
from abc import ABC
from abc import abstractmethod
from typing import Optional
from jira_telegram_bot.entities.speech import TranscriptionResult

Global Initiations:


__main__ Section:


Classes and Methods:
Class: SpeechProcessorInterface
  convert_audio_format (self: Any, input_path: str, target_format: str) -> str
  transcribe_audio (self: Any, audio_path: str, language: Optional[str]) -> str
  process_voice_message (self: Any, voice_file_path: str) -> TranscriptionResult
  translate_to_english (self: Any, text: str) -> str
  is_persian (self: Any, text: str) -> bool


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/interface/user_config_interface.py
================================================================================

Imports:
from __future__ import annotations
from abc import ABC
from abc import abstractmethod
from typing import Dict
from typing import Optional
from jira_telegram_bot.entities.user_config import UserConfig as UserConfigEntity

Global Initiations:


__main__ Section:


Classes and Methods:
Class: UserConfigInterface
  load_user_config (self: Any, user_config_path: str) -> Dict[str, UserConfigEntity]
  get_user_config (self: Any, username: str) -> Optional[UserConfigEntity]
  get_user_config_by_jira_username (self: Any, username: str) -> Optional[UserConfigEntity]
  save_user_config (self: Any, telegram_username: str, user_cfg: UserConfigEntity) -> None


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/interface/task_handler_interface.py
================================================================================

Imports:
from __future__ import annotations
from abc import ABC
from abc import abstractmethod
from jira_telegram_bot.use_cases.interface.task_interface import TaskInterface

Global Initiations:


__main__ Section:


Classes and Methods:
Class: TaskHandlerInterface
  __init__ (self: Any, task: TaskInterface) -> None
  get_handler (self: Any) -> None
  cancel (self: Any) -> None


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/interface/task_interface.py
================================================================================

Imports:
from __future__ import annotations
from abc import ABC
from abc import abstractmethod

Global Initiations:


__main__ Section:


Classes and Methods:
Class: TaskInterface
  __init__ (self: Any) -> None
  start (self: Any) -> None
  finalize_task (self: Any) -> None


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/interface/task_grouper_interface.py
================================================================================

Imports:
from __future__ import annotations
from typing import Dict
from typing import List
from jira_telegram_bot.entities.task import TaskData

Global Initiations:


__main__ Section:


Classes and Methods:
Class: ITaskGrouper
  group_tasks (self: Any, tasks: List[TaskData]) -> Dict[str, Dict[str, List[TaskData]]]


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/interface/telegram_gateway_interface.py
================================================================================

Imports:
from __future__ import annotations
from abc import ABC
from abc import abstractmethod
from typing import Optional

Global Initiations:


__main__ Section:


Classes and Methods:
Class: TelegramGatewayInterface
  send_message (self: Any, chat_id: int, text: str, reply_message_id: Optional[int], parse_mode: str) -> None


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/ai_agents/prompts.py
================================================================================

Imports:
from __future__ import annotations
from typing import Dict

Global Initiations:
COMPONENT_TASK_TEMPLATES = {'frontend': '\n    Component: Frontend Development\n    Consider:\n    - User interface components needed\n    - State management requirements\n    - API integration points\n    - Responsive design requirements\n    - Browser compatibility\n    - Performance optimizations\n    - Form validations\n    - Error handling patterns\n    ', 'backend': '\n    Component: Backend Development\n    Consider:\n    - API endpoints required\n    - Database schema changes\n    - Data validation rules\n    - Authentication/Authorization\n    - Rate limiting\n    - Caching strategies\n    - Error handling and logging\n    - Performance considerations\n    ', 'AI': '\n    Component: AI/NLP Development\n    Consider:\n    - Model selection/training requirements\n    - Data preprocessing needs\n    - Integration with existing AI pipeline\n    - Performance metrics\n    - Error handling and fallbacks\n    - Model evaluation criteria\n    - Scalability considerations\n    ', 'DevOPS': '\n    Component: DevOps/Infrastructure\n    Consider:\n    - Deployment requirements\n    - Infrastructure changes needed\n    - Monitoring and alerting\n    - Backup and recovery\n    - Security considerations\n    - Performance optimization\n    - Resource scaling\n    ', 'UI/UX': '\n    Component: UI/UX Design\n    Consider:\n    - User flow diagrams\n    - Wireframe requirements\n    - Design system updates\n    - Usability testing needs\n    - Accessibility requirements\n    - Design documentation\n    - User research tasks\n    '}
STORY_DECOMPOSITION_PROMPT = 'You are an expert technical project manager with deep experience in breaking down complex projects into actionable tasks. Your expertise lies in creating well-structured user stories and tasks that align with team capabilities and project goals.\n\nContext and Project Information:\n{project_context}\n\nDescription of Work Needed:\n{description}\n\nAvailable Departments/Components:\n{departments}\n\nDepartment Skills and Tools:\n{department_details}\n\nCurrent Assignees and Their Roles:\n{assignee_details}\n\nYour Task:\n1) First, break this down into coherent user stories that deliver complete features or capabilities\n2) For each story:\n   - Write a clear summary and description\n   - Identify which components/departments need to be involved\n   - For each component involved, create specific subtasks\n   - Each subtask should be achievable in 1-2 days\n3) Follow these principles:\n   - User stories should be independent and deliver value\n   - Tasks should have clear acceptance criteria\n   - Story points follow modified fibonacci (1,2,3,5,8,13)\n   - Subtask points range from 0.5 to 8\n   - Consider dependencies between components\n   - Assign tasks based on skill level (junior, mid-level, senior)\n\nRemember:\n- Tasks should be concrete and actionable\n- Include clear acceptance criteria\n- Consider team skills and capacity\n- Factor in technical dependencies\n- Make assignments based on experience level'
SUBTASK_DECOMPOSITION_PROMPT = "You are an expert technical project manager helping to break down an existing user story into specific subtasks.\n\nContext and Project Information:\n{project_context}\n\nParent Story Information:\n{parent_story}\n\nNew Requirements/Description:\n{description}\n\nAvailable Departments/Components:\n{departments}\n\nDepartment Skills and Tools:\n{department_details}\n\nCurrent Assignees and Their Roles:\n{assignee_details}\n\nYour Task:\n1) Review the parent story and new requirements\n2) Break down the work into specific subtasks that:\n   - Are aligned with the parent story's goals\n   - Can be completed in 1-2 days\n   - Have clear acceptance criteria\n   - Are assigned to specific components/departments\n3) For each subtask:\n   - Write a clear summary and description\n   - Specify the component/department\n   - Estimate story points (0.5-8)\n   - Consider skill level requirements\n   - Define acceptance criteria\n\nRemember:\n- Each subtask should be independently testable\n- Keep tasks small and focused\n- Include technical details needed for implementation\n- Consider dependencies between tasks\n- Ensure alignment with parent story goals\n"
COMPLEXITY_GUIDELINES = {'story_points': {'1-2': 'Very simple changes with minimal risk', '3-5': 'Standard complexity, well-understood work', '8': 'Complex changes affecting multiple components', '13': 'Very complex work with significant uncertainty'}, 'subtask_points': {'0.5': 'Trivial changes (< 2 hours)', '1': 'Simple, straightforward tasks (2-4 hours)', '2': 'Standard complexity (4-8 hours)', '3': 'More complex tasks (1-1.5 days)', '5': 'Complex tasks requiring deep focus (2-3 days)', '8': 'Very complex tasks (3-4 days)'}}
task_statistics = '\nYou are a JIRA query assistant. Your task is to translate complex natural language user requests into JIRA Query Language (JQL) format.\nThe user will provide a query in plain English, and you will convert it into a precise JQL statement that can be used in JIRA to retrieve or calculate the desired information.\n\nCapabilities:\n\nFilter by multiple criteria: Assignee, project, issue type, status, priority, components, etc.\nDate range filtering: Filter based on creation date, due date, or update date.\nSprint and Agile board queries: Filter issues by the current sprint or specific Agile boards.\nAggregation and calculation: Sum, average, or estimate fields like time tracking, story points, etc.\nExamples:\n\nUser Query: "Show all tasks assigned to John Doe that are due next week."\nJIRA Query: assignee = "John Doe" AND due >= startOfWeek(1) AND due <= endOfWeek(1)\n\nUser Query: "Find all open bugs in the \'Mobile App\' project."\nJIRA Query: project = "Mobile App" AND issuetype = Bug AND status = Open\n\nUser Query: "List all high-priority issues updated in the last 24 hours."\nJIRA Query: priority = High AND updated >= -1d\n\nUser Query: "Sum and estimate the time remaining for each component to be completed in the current sprint."\nJIRA Query: Sprint in openSprints() AND remainingEstimate is not EMPTY ORDER BY component ASC\n\n\nUser Query: "Calculate the total story points of all \'In Progress\' issues for the current sprint."\nJIRA Query: status = "In Progress" AND Sprint in openSprints() AND "Story Points" is not EMPTY\n\nNow, translate the following user query into a JIRA query:\n\nUser Query: {user_query}\n\nJIRA Query:\n\n\n'

__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/ai_agents/__init__.py
================================================================================

Imports:


Global Initiations:


__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/ai_agents/create_ticketing_issue.py
================================================================================

Imports:
from __future__ import annotations
from typing import Dict
from langchain.output_parsers import ResponseSchema, StructuredOutputParser
from langchain_core.prompts import PromptTemplate
from langchain_openai import ChatOpenAI
from jira_telegram_bot.settings import OPENAI_SETTINGS

Global Initiations:
schema = [ResponseSchema(name='task_info', description="A JSON object containing summary, task_type, label, and description fields. Example: {'summary': 'Task summary', 'task_type': 'Bug', 'description': 'Task description', 'label': '#ID121'}", type='json')]
parser = StructuredOutputParser.from_response_schemas(schema)
format_instructions = parser.get_format_instructions()
template_text = '\n                    You are given the following content from a user:\n\n                    {content}\n\n                    Your job is to analyze this content and provide structured output for creating a task for jira.\n                    keep the same language as the content.\n\n\n                    {format_instructions}\n\n                    Instructions:\n                    1. "task_type": The type of task must only be Task or Bug.\n                    2. "summary": the summary must be a single line. with the same language as content. If exists in content, keep #ID number in the summary.\n                    3. "description": the description must be a single line. with the same language as content.\n                    4. "label": label is the #ID if the content has it.\n                    '
llm = ChatOpenAI(model_name='gpt-4o-mini', openai_api_key=OPENAI_SETTINGS.token, temperature=0.2)
prompt = PromptTemplate(template=template_text, input_variables=['content'], partial_variables={'format_instructions': format_instructions})
chain = prompt | llm | parser
result = chain.invoke(input={'content': content})

__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/ai_agents/parse_jira_prompt_usecase.py
================================================================================

Imports:
from __future__ import annotations
from typing import Dict
from langchain.output_parsers import ResponseSchema
from langchain.output_parsers import StructuredOutputParser
from langchain.prompts import PromptTemplate
from jira_telegram_bot.use_cases.interface.openai_gateway_interface import OpenAIGatewayInterface

Global Initiations:
schema = [ResponseSchema(name='task_info', description='A JSON object containing summary, task_type, label, and description fields.', type='json')]
parser = StructuredOutputParser.from_response_schemas(schema)
format_instructions = parser.get_format_instructions()
template_text = '\n            You are given the following content from a user:\n\n            {content}\n\n            Your job is to analyze this content and provide structured output for creating a task for Jira.\n            Keep the same language as the content.\n\n            {format_instructions}\n\n            Instructions:\n            1. "task_type": must only be Task or Bug.\n            2. "summary": single line. If #ID is in content, keep it.\n            3. "description": single line.\n            4. "label": #ID if content has it.\n        '
llm = self._openai_gateway.get_llm()
prompt = PromptTemplate(template=template_text, input_variables=['content'], partial_variables={'format_instructions': format_instructions})
chain = prompt | llm | parser
result = chain.invoke(input={'content': content})

__main__ Section:


Classes and Methods:
Class: ParseJiraPromptUseCase
  __init__ (self: Any, openai_gateway: OpenAIGatewayInterface) -> None
  run (self: Any, content: str) -> Dict[str, str]
      calls on dependencies: _openai_gateway.get_llm


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/telegram_commands/advanced_task_creation.py
================================================================================

Imports:
from __future__ import annotations
import json
from typing import Any
from typing import Dict
from typing import List
from typing import Optional
from langchain.output_parsers import ResponseSchema
from langchain.output_parsers import StructuredOutputParser
from langchain_core.prompts import PromptTemplate
from langchain_google_genai import ChatGoogleGenerativeAI
from jira_telegram_bot import DEFAULT_PATH
from jira_telegram_bot import LOGGER
from jira_telegram_bot.entities.task import TaskData
from jira_telegram_bot.settings import GEMINI_SETTINGS as gemini_connection_settings
from jira_telegram_bot.use_cases.interface.task_manager_repository_interface import TaskManagerRepositoryInterface
from jira_telegram_bot.use_cases.interface.user_config_interface import UserConfigInterface
import asyncio
from jira_telegram_bot.adapters.repositories.jira.jira_server_repository import JiraRepository
from jira_telegram_bot.adapters.user_config import UserConfig
from jira_telegram_bot.settings import JIRA_SETTINGS

Global Initiations:
jira_repo = JiraRepository(settings=JIRA_SETTINGS)
task_creator = AdvancedTaskCreation(jira_repo=jira_repo, user_config=UserConfig())
description = 'The task is to connect to the widget through a JavaScript snippet.\n    This story point belongs to the front-end department.\n    It is estimated to take 16 hours to prepare this task, which includes changes to the service connection\n    page with the ability to add a new section for connecting to the widget service.\n    On this page, I need to modify the built JavaScript snippet for the user who enters the chat page,\n    the plugin page. On the panel page, I should be able to copy the necessary code for his web clock\n    and place it in his web clock.'
result = asyncio.run(task_creator.create_structured_user_story(description=description, project_key='PARSCHAT', epic_key='PARSCHAT-15'))
tasks_data = self._parse_task_description(description=description, project_info=project_info, task_type=task_type)
created_tasks = []
epic_context = {}
parent_story_context = {}
user_story_content = await self._generate_structured_user_story(description=description, project_info=project_info, epic_context=epic_context, parent_story_context=parent_story_context)
epic_context = epic_context or {}
parent_story_context = parent_story_context or {}
business_goal = project_info.get('project_info', {}).get('objective', 'Improve user experience')
product_area = project_info.get('project_info', {}).get('description', 'Software Product')
primary_persona = 'User'
schema = [ResponseSchema(name='user_story', description='Dictionary containing:\n                summary (string): A concise title for the story,\n                description (string): Full user story with narrative, acceptance criteria, and definition of done,\n                component (string): Primary team/department responsible,\n                story_points (number): Estimated story points (1-13),\n                priority (string): High, Medium, or Low', type='json')]
parser = StructuredOutputParser.from_response_schemas(schema)
format_instructions = parser.get_format_instructions()
template = 'You are an experienced Agile Product Owner.\n\nContext:\n\nProduct/Feature Area: {product_area}\n\nBusiness Goal / OKR: {business_goal}\n\nPrimary Persona: {primary_persona}\n\nDependencies / Constraints: {dependencies}\n\nDescription of work: {description}\n\n{epic_context}\n\n{parent_story_context}\n\nInstructions:\n\nWrite one INVEST-compliant user story in the format:\n\'As a <persona role>, I want <capability> so that <benefit/value>.\'\n\nAdd a concise narrative (≤ 3 sentences) that explains why this story matters to the business goal.\n\nProvide Acceptance Criteria using Gherkin-style "Given / When / Then" bullets (≥ 3 distinct criteria, covering happy-path and one edge case).\n\nList Non-functional Requirements that could cause the story to fail if ignored (e.g., performance, security, accessibility).\n\nSuggest Sizing hints (story-points or T-shirt size) with a short rationale.\n\nSuggest Risks & Open Questions the team should discuss during refinement.\n\nEnd with a Definition of Done checklist that references code, tests, documentation, and release validation.\n\nTone & Style:\n- Clear, testable, and free of jargon\n- Bullet points where possible\n- Avoid passive voice\n- Generate the result in google doc format\n- Use markdown for formatting\n\n{format_instructions}\n'
epic_context_text = ''
parent_context_text = ''
prompt = PromptTemplate(template=template, input_variables=['product_area', 'business_goal', 'primary_persona', 'dependencies', 'description', 'epic_context', 'parent_story_context'], partial_variables={'format_instructions': format_instructions})
dependencies = 'Integration with existing systems required'
llm_response = self.llm.invoke(prompt.format(product_area=product_area, business_goal=business_goal, primary_persona=primary_persona, dependencies=dependencies, description=description, epic_context=epic_context_text, parent_story_context=parent_context_text))
content = llm_response.content
dept_details = []
assignee_details = []
parser = StructuredOutputParser.from_response_schemas(schema)
format_instructions = parser.get_format_instructions()
prompt = PromptTemplate(template=template, input_variables=['project_context', 'description', 'departments', 'department_details', 'assignee_details'], partial_variables={'format_instructions': format_instructions})
llm_response = self.llm.invoke(prompt.format(project_context=project_info['project_info']['description'], description=description, departments=', '.join(project_info['departments'].keys()), department_details='\n\n'.join(dept_details), assignee_details='\n'.join(assignee_details)))
content = llm_response.content
dept_leads = {comp['name']: comp['lead'] for comp in project_info['components']}
dept_members = {}
projects_info = json.load(f)
project_info = projects_info.get(project_key)
projects_info = json.load(f)
project_info = projects_info.get(project_key)
epic_issue = self.jira_repo.get_issue(epic_key)
parent_issue = self.jira_repo.get_issue(parent_story_key)
parent_issue = self.jira_repo.get_issue(parent_story_key)
original_description = parent_issue.fields.description or ''
updated_description = self._merge_descriptions(original_description, user_story_content['description'])
issue_fields = {'description': updated_description}
story_data = TaskData(project_key=project_key, summary=user_story_content['summary'], description=updated_description, components=[user_story_content['component']], story_points=user_story_content.get('story_points', 5), task_type='Story', priority=user_story_content.get('priority', 'Medium'))
components = []
story_data = TaskData(project_key=project_key, summary=user_story_content['summary'], description=user_story_content['description'], components=components, story_points=user_story_content.get('story_points', 5), task_type='Story', priority=user_story_content.get('priority', 'Medium'), epic_link=epic_key)
new_issue = self.jira_repo.create_task(story_data)
primary_persona = next(iter(project_info['personas']), 'User')
epic_context_text = f'Epic Information:\nEpic Key: {epic_context.get('key', '')}\nEpic Summary: {epic_context.get('summary', '')}\nEpic Description: {epic_context.get('description', '')}'
parent_context_text = f'Parent Story Information:\nStory Key: {parent_story_context.get('key', '')}\nStory Summary: {parent_story_context.get('summary', '')}\nStory Description: {parent_story_context.get('description', '')}'
parsed_data = parser.parse(content)
new_sections = {}
possible_sections = ['Acceptance Criteria', 'Non-functional Requirements', 'Sizing', 'Risks & Open Questions', 'Definition of Done']
result = original
schema = [ResponseSchema(name='stories', description='Array of story objects. Each story has:\n                    summary (string),\n                    description (string),\n                    story_points (number between 1-13),\n                    priority (string: High, Medium, Low),\n                    component_tasks (array of component task objects)', type='json')]
schema = [ResponseSchema(name='subtasks', description='Array of subtask objects. Each subtask has:\n                    summary (string),\n                    description (string),\n                    story_points (number between 0.5-8),\n                    component (string),\n                    assignee (string, optional)', type='json')]
template = 'You are an expert technical project manager with deep experience in breaking down complex projects into actionable tasks.\n\nContext and Project Information:\n{project_context}\n\nDescription of Work Needed:\n{description}\n\nAvailable Departments/Components:\n{departments}\n\nDepartment Skills and Tools:\n{department_details}\n\nCurrent Assignees and Their Roles:\n{assignee_details}\n\nYour Task:\n1) Break this down into coherent user stories that deliver complete features or capabilities\n2) For each story:\n   - Write a clear summary and description\n    - Generate description in markdown format\n   - Identify which components/departments need to be involved\n   - For each component involved, create specific subtasks\n   - Each subtask should be achievable in 1-2 days\n3) Follow these principles:\n   - User stories should be independent and deliver value\n   - Tasks should have clear acceptance criteria\n   - Story points follow modified fibonacci (1,2,3,5,8,13)\n   - Subtask points range from 0.5 to 8\n   - Consider dependencies between components\n   - Assign tasks based on skill level (junior, mid-level, senior)\n\n{format_instructions}'
template = 'You are an expert technical project manager who specializes in breaking down tasks into actionable subtasks.\n\nContext and Project Information:\n{project_context}\n\nDescription of Work Needed:\n{description}\n\nAvailable Departments/Components:\n{departments}\n\nDepartment Skills and Tools:\n{department_details}\n\nCurrent Assignees and Their Roles:\n{assignee_details}\n\nYour Task:\n1) Break this down into specific subtasks that can each be completed in 1-2 days\n2) For each subtask:\n   - Create a clear summary and description with acceptance criteria\n   - Generate description in markdown format\n   - Assign to appropriate component/department\n   - Estimate story points (0.5-8)\n   - Consider which team member is best suited (optional)\n3) Ensure subtasks are:\n   - Concrete and actionable\n   - Have clear success criteria\n   - Properly sized for 1-2 days of work\n\n{format_instructions}'
parsed_data = parser.parse(content)
dept = assignee['department']
story_data = TaskData(project_key=project_key, summary=story['summary'], description=story['description'], components=[ct['component'] for ct in story['component_tasks']], story_points=story['story_points'], task_type='Story', priority=story['priority'], epic_link=epic_key)
story_issue = self.jira_repo.create_task(story_data)
subtask_data = TaskData(project_key=project_key, summary=subtask['summary'], description=subtask['description'], components=[subtask['component']], story_points=subtask['story_points'], assignee=subtask.get('assignee'), task_type='Sub-task', parent_issue_key=parent_story_key)
subtask_issue = self.jira_repo.create_task(subtask_data)
epic_context = {'key': epic_key, 'summary': epic_issue.fields.summary, 'description': epic_issue.fields.description or ''}
parent_story_context = {'key': parent_story_key, 'summary': parent_issue.fields.summary, 'description': parent_issue.fields.description or ''}
components = [user_story_content['component']]
parsed_data = self._assign_tasks(parsed_data, project_info)
dept = comp_tasks['component']
members = dept_members[dept]
leader = dept_leads.get(dept)
seniors = [m for m in members if m['role'] == 'Senior Developer']
mids = [m for m in members if m['role'] == 'Mid-level Developer']
juniors = [m for m in members if m['role'] == 'Junior Developer']
start_idx = new_content.find(section)
next_section_idx = float('inf')
start_idx = result.find(section)
next_section_idx = float('inf')
subtask_data = TaskData(project_key=project_key, summary=subtask['summary'], description=subtask['description'], components=[comp_tasks['component']], story_points=subtask['story_points'], assignee=subtask.get('assignee'), task_type='Sub-task', parent_issue_key=story_issue.key)
subtask_issue = self.jira_repo.create_task(subtask_data)
result = result[:start_idx] + content + result[next_section_idx:]
result = result[:start_idx] + content
section_idx = new_content[start_idx + len(section):].find(next_section) + start_idx + len(section)
next_section_idx = min(next_section_idx, section_idx)
section_idx = result[start_idx + len(section):].find(next_section) + start_idx + len(section)
next_section_idx = min(next_section_idx, section_idx)

__main__ Section:
if __name__ == '__main__':
    import asyncio
    from jira_telegram_bot.adapters.repositories.jira.jira_server_repository import JiraRepository
    from jira_telegram_bot.adapters.user_config import UserConfig
    from jira_telegram_bot.settings import JIRA_SETTINGS
    jira_repo = JiraRepository(settings=JIRA_SETTINGS)
    task_creator = AdvancedTaskCreation(jira_repo=jira_repo, user_config=UserConfig())
    description = 'The task is to connect to the widget through a JavaScript snippet.\n    This story point belongs to the front-end department.\n    It is estimated to take 16 hours to prepare this task, which includes changes to the service connection\n    page with the ability to add a new section for connecting to the widget service.\n    On this page, I need to modify the built JavaScript snippet for the user who enters the chat page,\n    the plugin page. On the panel page, I should be able to copy the necessary code for his web clock\n    and place it in his web clock.'
    result = asyncio.run(task_creator.create_structured_user_story(description=description, project_key='PARSCHAT', epic_key='PARSCHAT-15'))
    print(result.description)

Classes and Methods:
Class: AdvancedTaskCreation
  __init__ (self: Any, jira_repo: TaskManagerRepositoryInterface, user_config: UserConfigInterface) -> None
  create_tasks (self: Any, description: str, project_key: str, epic_key: Optional[str], parent_story_key: Optional[str], task_type: str) -> List[TaskData]
      calls on dependencies: jira_repo.create_task
  create_structured_user_story (self: Any, description: str, project_key: str, epic_key: Optional[str], parent_story_key: Optional[str]) -> TaskData
      calls on dependencies: jira_repo.create_task, jira_repo.get_issue, jira_repo.update_issue_from_fields
  _generate_structured_user_story (self: Any, description: str, project_info: Dict[str, Any], epic_context: Dict[str, Any], parent_story_context: Dict[str, Any]) -> Dict[str, Any]
      calls on dependencies: llm.invoke
  _merge_descriptions (self: Any, original: str, new_content: str) -> str
  _parse_task_description (self: Any, description: str, project_info: Dict[str, Any], task_type: str) -> Dict[str, Any]
      calls on dependencies: llm.invoke
  _assign_tasks (self: Any, parsed_data: Dict[str, Any], project_info: Dict[str, Any]) -> Dict[str, Any]


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/telegram_commands/task_get_users_time.py
================================================================================

Imports:
from __future__ import annotations
import io
from collections import defaultdict
from datetime import datetime
import xlsxwriter
from telegram import Update
from telegram.ext import CallbackContext
from telegram.ext import ConversationHandler
from jira_telegram_bot import LOGGER

Global Initiations:
ENTER_FIRST_DAY = 1
ENTER_DAYS = 2
username = update.effective_user.username
text = update.message.text.strip()
text = update.message.text.strip()
days = int(text)
jql = f'updated >= "{first_day.strftime('%Y-%m-%d')}" AND worklogDate >= "{first_day.strftime('%Y-%m-%d')}" ORDER BY updated DESC'
user_data_map = defaultdict(lambda: {'total_time': 0, 'remote_time': 0, 'weekend_holiday_time': 0})
weekday = date_obj.weekday()
output_stream = io.BytesIO()
workbook = xlsxwriter.Workbook(output_stream, {'in_memory': True})
worksheet = workbook.add_worksheet('Users Time')
headers = ['Person Name', 'Total Time (hrs)', 'Remote Time (hrs)', 'Weekend/Holiday Time (hrs)']
row = 1
first_day = datetime.strptime(text, '%Y-%m-%d')
issues = self.jira.search_for_issues(jql, max_results=1000)
total_hours = data['total_time'] / 3600
remote_hours = data['remote_time'] / 3600
weekend_holiday_hours = data['weekend_holiday_time'] / 3600
worklogs = self.jira.jira.worklogs(issue.key)
author_name = wl.author.displayName
time_spent_seconds = wl.timeSpentSeconds or 0
comment = (wl.comment or '').lower()
started_str = wl.started
started_date = datetime.strptime(started_str.split('.')[0], '%Y-%m-%dT%H:%M:%S')
started_date = None

__main__ Section:


Classes and Methods:
Class: TaskGetUsersTime
  __init__ (self: Any, jira: Any, authorized_usernames: list[str]) -> None
  start_get_users_time (self: Any, update: Update, context: CallbackContext) -> int
  get_first_day (self: Any, update: Update, context: CallbackContext) -> int
  get_days (self: Any, update: Update, context: CallbackContext) -> int
  _is_weekend_or_persian_holiday (self: Any, date_obj: datetime) -> bool
  _generate_and_send_excel (self: Any, update: Update, user_data_map: dict) -> None


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/telegram_commands/__init__.py
================================================================================

Imports:


Global Initiations:


__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/telegram_commands/user_settings.py
================================================================================

Imports:
from __future__ import annotations
from typing import List
from telegram import InlineKeyboardButton
from telegram import InlineKeyboardMarkup
from telegram import Update
from telegram.ext import CallbackContext
from telegram.ext import ConversationHandler
from jira_telegram_bot.adapters.services.telegram.authentication import check_user_allowed
from jira_telegram_bot.use_cases.interface.user_config_interface import UserConfigInterface

Global Initiations:
keyboard = []
row = [InlineKeyboardButton('Modify My Settings', callback_data='self_settings')]
is_admin = update.message.from_user.username in self.admin_usernames
kb = self.build_main_menu(is_admin)
query = update.callback_query
data = query.data
user_username = query.from_user.username
is_admin = user_username in self.admin_usernames
query = update.callback_query
data = query.data
chosen_user = data.split('|')[1]
user_cfg = self.user_config_repo.get_user_config(chosen_user)
field_names = ['project', 'component', 'task_type', 'story_point', 'attachment', 'epic_link', 'release', 'sprint', 'assignee', 'priority', 'deadline', 'labels']
rows = []
temp_row = []
query = update.callback_query
data = query.data
username = context.user_data.get('current_edit_username', None)
user_cfg = self.user_config_repo.get_user_config(username)
field_obj = getattr(user_cfg, field_name, None)
kb = self.build_toggles_kb(user_cfg)
query = update.callback_query
username = context.user_data.get('current_edit_username', None)
new_username = update.message.text.strip().lstrip('@')
jira_username = update.message.text.strip()
chat_id_text = update.message.text.strip()
new_uname = context.user_data['new_user_username']
new_jira = context.user_data['new_user_jira_username']
user_cfg = self.user_config_repo.create_user_config(telegram_username=new_uname, telegram_user_chat_id=chat_id, jira_username=new_jira)
query = update.callback_query
new_uname = context.user_data.get('current_edit_username', '')
user_cfg = self.user_config_repo.get_user_config(user_username)
all_users = self.user_config_repo.list_all_users()
buttons = []
field_config = getattr(user_cfg, fname, None)
check_mark = '✔' if field_config.set_field else ''
button_text = f'{fname} {check_mark}'
cb_data = f'toggle|{fname}'
chat_id = int(chat_id_text)
user_cfg = self.user_config_repo.create_user_config(telegram_username=user_username, telegram_user_chat_id=query.from_user.id, jira_username=user_username)
temp_row = []

__main__ Section:


Classes and Methods:
Class: UserSettingsConversation
  __init__ (self: Any, user_config_repo: UserConfigInterface, admin_usernames: List[str]) -> None
  build_main_menu (self: Any, is_admin: bool) -> InlineKeyboardMarkup
  start (self: Any, update: Update, context: CallbackContext) -> int
  handle_main_menu (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: user_config_repo.create_user_config, user_config_repo.get_user_config, user_config_repo.list_all_users
  choose_user_to_edit (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: user_config_repo.get_user_config
  build_toggles_kb (self: Any, user_cfg: Any) -> InlineKeyboardMarkup
  toggle_field (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: user_config_repo.get_user_config, user_config_repo.save_user_config
  done_editing (self: Any, update: Update, context: CallbackContext) -> int
  wait_new_user_username (self: Any, update: Update, context: CallbackContext) -> int
  wait_new_user_jira_username (self: Any, update: Update, context: CallbackContext) -> int
  wait_new_user_chat_id (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: user_config_repo.create_user_config
  done_editing_new_user (self: Any, update: Update, context: CallbackContext) -> int
  cancel (self: Any, update: Update, context: CallbackContext) -> int


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/telegram_commands/board_summary_generator.py
================================================================================

Imports:
from __future__ import annotations
import re
from typing import List
from typing import Optional
from telegram import InlineKeyboardButton
from telegram import InlineKeyboardMarkup
from telegram import Update
from telegram.ext import CallbackContext
from telegram.ext import ConversationHandler
from jira_telegram_bot import LOGGER
from jira_telegram_bot.entities.task import TaskData
from jira_telegram_bot.adapters.services.telegram.authentication import check_user_allowed
from jira_telegram_bot.use_cases.telegram_commands.board_summarizer import TaskProcessor
from jira_telegram_bot.use_cases.interface.task_manager_repository_interface import TaskManagerRepositoryInterface

Global Initiations:
escaped_text = re.sub('(?<!\\\\)([_*\\[\\]\\(\\)~`>\\#+\\-=|{}\\.!])', '\\\\\\1', text)
keyboard = [[InlineKeyboardButton(text=option, callback_data=data[i + j]) for j, option in enumerate(options[i:i + row_width])] for i in range(0, len(options), row_width)]
task_data = TaskData()
projects = self.jira_repository.get_projects()
options = [project.name for project in projects]
data = [project.key for project in projects]
reply_markup = self.build_keyboard(options, data, row_width=3)
query = update.callback_query
project_key = query.data
components = self.jira_repository.get_project_components(task_data.project_key)
query = update.callback_query
assignees = self.jira_repository.get_assignees(task_data.project_key)
query = update.callback_query
username_query = update.message.text.strip()
matching_users = self.jira_repository.search_users(username_query)
query = update.callback_query
active_and_future_sprints = [sprint for sprint in task_data.sprints if sprint.state in ('active', 'future')]
query = update.callback_query
query = update.callback_query
releases = [version for version in self.jira_repository.get_project_versions(task_data.project_key) if not version.released]
query = update.callback_query
jql_parts = [f'project = "{task_data.project_key}"']
jql_query = ' AND '.join(jql_parts)
data = options
options = [component.name for component in components]
data = [component.name for component in components]
reply_markup = self.build_keyboard(options, data, include_skip=True)
options = assignees
data = assignees
extra_buttons = [[InlineKeyboardButton('Others', callback_data='others')]]
reply_markup = self.build_keyboard(options, data, row_width=2, include_skip=True, extra_buttons=extra_buttons)
options = matching_users
data = matching_users
extra_buttons = [[InlineKeyboardButton('Others', callback_data='others')]]
reply_markup = self.build_keyboard(options, data, row_width=2, include_skip=True, extra_buttons=extra_buttons)
options = [sprint.name for sprint in active_and_future_sprints]
data = [str(sprint.id) for sprint in active_and_future_sprints]
reply_markup = self.build_keyboard(options, data, include_skip=True)
options = [epic.fields.summary for epic in task_data.epics]
data = [epic.key for epic in task_data.epics]
reply_markup = self.build_keyboard(options, data, include_skip=True, row_width=3)
options = [version.name for version in releases]
reply_markup = self.build_keyboard(options, include_skip=True, row_width=3)
issues = self.jira_repository.jira.search_issues(jql_query)
response_text = f'Found the following tasks: for {jql_parts} \n\n'
tasks = []
issue_summary = escape_markdown_v2(response_text)
result = self.summary_generator.process_tasks(tasks)
error_message = f'Failed to fetch tasks: {e}'
task = self.jira_repository.create_task_data_from_jira_issue(issue)

__main__ Section:


Classes and Methods:
Class: BoardSummaryGenerator
  __init__ (self: Any, jira_repository: TaskManagerRepositoryInterface, summary_generator: TaskProcessor) -> None
  build_keyboard (self: Any, options: List[str], data: Optional[List[str]], include_skip: bool, row_width: int, extra_buttons: Optional[List[List[InlineKeyboardButton]]]) -> InlineKeyboardMarkup
  start (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: jira_repository.get_projects
  select_project (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: jira_repository.get_board_id, jira_repository.get_epics, jira_repository.get_sprints
  ask_component (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: jira_repository.get_project_components
  add_component (self: Any, update: Update, context: CallbackContext) -> int
  ask_assignee (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: jira_repository.get_assignees
  add_assignee (self: Any, update: Update, context: CallbackContext) -> int
  search_assignee (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: jira_repository.search_users
  select_assignee_from_search (self: Any, update: Update, context: CallbackContext) -> int
  ask_sprint (self: Any, update: Update, context: CallbackContext) -> int
  add_sprint (self: Any, update: Update, context: CallbackContext) -> int
  ask_epic (self: Any, update: Update, context: CallbackContext) -> int
  add_epic (self: Any, update: Update, context: CallbackContext) -> int
  ask_release (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: jira_repository.get_project_versions
  add_release (self: Any, update: Update, context: CallbackContext) -> int
  fetch_tasks (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: jira_repository.create_task_data_from_jira_issue, jira_repository.jira.search_issues, summary_generator.process_tasks


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/telegram_commands/board_summarizer.py
================================================================================

Imports:
from __future__ import annotations
from collections import defaultdict
from typing import Dict
from typing import List
from langchain import LLMChain
from langchain import PromptTemplate
from langchain_openai import ChatOpenAI
from jira_telegram_bot.entities.task import TaskData
from jira_telegram_bot.use_cases.interface.summary_generator_interface import ISummaryGenerator
from jira_telegram_bot.use_cases.interface.task_grouper_interface import ITaskGrouper

Global Initiations:
llm = ChatOpenAI(model_name='o3-mini', openai_api_key=settings.token)
prompt = PromptTemplate(input_variables=['grouped_tasks'], template='\nشما یک فهرست از وظایف (Tasks) دارید که بررسی یا تکمیل شده\u200cاند. اطلاعات هر وظیفه شامل این موارد است:\n\nAssignee (شخص مسئول)\nSummary (خلاصه کار)\nComponent (دپارتمان، در صورت وجود)\nEpic (اپیک، در صورت وجود)\nRelease Version (نسخه انتشار، در صورت وجود)\nورودی شما در قالب متغیری با نام {grouped_tasks} ارائه می\u200cشود که حاوی کلیهٔ وظایف و جزئیات آن\u200cهاست.\n\nلطفاً خروجی نهایی را به زبان فارسی آماده کنید تا در تلگرام قابل خواندن و جذاب باشد. دستورالعمل\u200cها به شکل زیر است:\n\nگروه\u200cبندی بر اساس دپارتمان (Component)\n\nهر دپارتمان را با عنوان **گروه: [نام دپارتمان]** مشخص کنید.\nاگر دپارتمان خالی یا None بود، وظیفه را زیر **بدون دپارتمان** قرار دهید.\nزیرگروه\u200cبندی بر اساس اپیک (Epic)\n\nدر هر گروه (دپارتمان)، وظایف را براساس اپیک تفکیک کنید.\nاگر اپیک خالی یا None بود، از **بدون اپیک** استفاده کنید.\nفرمت نمایش وظایف\n\nهر وظیفه را در یک خط مجزا بنویسید.\nاز نماد یا ایموجی (مثلاً ➖ یا •) ابتدای خط برای جذابیت استفاده کنید.\nدر ادامه، نام وظیفه را بین براکت بنویسید: [خلاصه وظیفه]\nدر پرانتز، مسئول را با کلیدواژه مسئول: ذکر کنید. اگر نسخه (Release Version) موجود بود، بعد از آن با کلیدواژه نسخه: اضافه کنید.\nمثال وجود نسخه:\n\n➖ [خلاصه کار] (مسئول: [نام], نسخه: [شماره نسخه])\n\nمثال عدم وجود نسخه:\n\n➖ [خلاصه کار] (مسئول: [نام])\nخلاصهٔ پایانی در هر اپیک\n\nپس از اتمام وظایف مرتبط با یک اپیک، یک خلاصهٔ مختصر با عنوانی مثل 📄 خلاصه: اضافه کنید.\nدر این بخش، به دستاوردها، افراد کلیدی و تمرکز اصلی اشاره نمایید.\nنتیجه\u200cگیری کلی\n\nدر پایان تمام گروه\u200cها، یک خلاصهٔ جامع با عنوانی مانند:\n\n✅ نتیجه\u200cگیری کلی:\nبنویسید تا بیانگر هماهنگی بین گروه\u200cها و دستاورد نهایی باشد.\nاستایل و نکات پایانی\n\nمی\u200cتوانید از Bold برای تیترها و ایتالیک برای تأکید استفاده کنید.\nاز ایموجی\u200cها بهره ببرید تا متن جذاب\u200cتر شود.\nساختار را با خط تفکیک (────────────────────────────) یا هر روش مناسب دیگر خوانا نگه دارید.\nاگر فیلد Epic یا Release Version خالی یا None بود، آن را نادیده بگیرید و اصلاً ذکر نکنید.\nنمونه خروجی پیشنهادی\nless\nCopy\nEdit\n🔰 خلاصه نهایی وظایف پروژه 🔰\n────────────────────────────\n🏷️ گروه: بدون دپارتمان\n\nاپیک: بدون اپیک\n➖ [نام وظیفه اول] (مسئول: [نام], نسخه: [۱.۰])\n➖ [نام وظیفه دوم] (مسئول: [نام])\n\n📄 خلاصه:\nدر این بخش، [نام افراد درگیر] با تمرکز بر [اهداف اصلی]، تغییرات قابل ملاحظه\u200cای انجام دادند...\n\n────────────────────────────\n🏷️ گروه: [نام دپارتمان]\n\nاپیک: [نام اپیک]\n➖ [نام وظیفه] (مسئول: [نام])\n➖ ...\n\n📄 خلاصه:\n...\n\n✅ نتیجه\u200cگیری کلی:\n[چکیده\u200cای از همکاری بین گروه\u200cها و دستاورد نهایی] ')
llm_chain = LLMChain(llm=llm, prompt=prompt)
component_groups = defaultdict(lambda: defaultdict(list))
summaries = []
final_summary = '\n'.join(summaries)
response = self.llm_chain.run(final_summary)
grouped_tasks = self.grouper.group_tasks(tasks)
summary = self.generator.generate_summary(grouped_tasks)
component_key = task.component if task.component else 'no executive department'
epic_key = task.epics if task.epics else 'no epic'
component_summary = f'**executive department: {component}**\n'
epic_summary = f'  - **epic: {epic}**\n'
task_summary = f'task {task.summary}    - وظیفه توسط {task.assignee} برای نسخه {task.release} انجام شد. جزئیات: {task.description}\n'

__main__ Section:


Classes and Methods:
Class: TaskGrouper
  group_tasks (self: Any, tasks: List[TaskData]) -> Dict[str, Dict[str, List[TaskData]]]
Class: SummaryGenerator
  __init__ (self: Any, llm_chain: LLMChain) -> None
  generate_summary (self: Any, grouped_tasks: Dict[str, Dict[str, List[TaskData]]]) -> str
      calls on dependencies: llm_chain.run
Class: TaskProcessor
  __init__ (self: Any, llm_chain: LLMChain, grouper: ITaskGrouper, generator: ISummaryGenerator) -> None
  process_tasks (self: Any, tasks: List[TaskData]) -> str


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/telegram_commands/task_status.py
================================================================================

Imports:
from telegram import Update
from telegram.ext import CallbackContext, ConversationHandler
from jira import JIRA
from jira_telegram_bot import LOGGER
from jira_telegram_bot.settings import JIRA_BOARD_SETTINGS

Global Initiations:
TASK_ID = 1
task_id = update.message.text.strip()
issues = self.jira.search_issues(f"project = '{self.board_settings.board_name}' AND key = '{self.board_settings.board_name}-{task_id}'")
issue = issues[0]
summary = issue.fields.summary
priority = issue.fields.priority.name if issue.fields.priority else 'Not set'
description = issue.fields.description or 'No description'
assignee = issue.fields.assignee.displayName
status = issue.fields.status.name
response = f'*Summary*: {summary}\n\n*Priority*: {priority}\n\n*Description*: {description}\n\n*Estimated Remaining Time \\(H\\)*: {estimated_time}\n\n*Assignee*: {assignee}\n\n🔑 *Status*: {status}\n\n'
estimated_time = issue.fields.customfield_10106 * 8 - int(issue.fields.timespent / 3600)
estimated_time = 'None'

__main__ Section:


Classes and Methods:
Class: TaskStatus
  __init__ (self: Any, jira: JIRA) -> None
  get_task_status (self: Any, update: Update, context: CallbackContext) -> int
  fetch_task_details (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: jira.search_issues


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/telegram_commands/create_task.py
================================================================================

Imports:
from __future__ import annotations
import datetime
from io import BytesIO
from typing import Any
from typing import Dict
from typing import List
from typing import Optional
import aiohttp
from telegram import CallbackQuery
from telegram import InlineKeyboardButton
from telegram import InlineKeyboardMarkup
from telegram import Update
from telegram.ext import CallbackContext
from telegram.ext import ConversationHandler
from jira_telegram_bot import LOGGER
from jira_telegram_bot.entities.task import TaskData
from jira_telegram_bot.settings import JIRA_SETTINGS
from jira_telegram_bot.use_cases.interface.task_manager_repository_interface import TaskManagerRepositoryInterface
from jira_telegram_bot.use_cases.interface.user_config_interface import UserConfigInterface

Global Initiations:
DEADLINE_OPTIONS = [('0', 'Current Day'), ('1', '1'), ('2', '2'), ('3', '3'), ('4', '4'), ('5', '5'), ('6', '6'), ('7', '7'), ('8', '8'), ('9', '9'), ('10', '10'), ('11', '11'), ('12', '12'), ('13', '13'), ('14', '14'), ('21', '21'), ('30', '30')]
keyboard = []
keyboard = []
row_width = 2
bottom_row = [InlineKeyboardButton('Done', callback_data='cmp_done'), InlineKeyboardButton('Skip', callback_data='skip')]
keyboard = []
row_width = 2
bottom_row = [InlineKeyboardButton('New Label', callback_data='lbl_new'), InlineKeyboardButton('Done', callback_data='lbl_done'), InlineKeyboardButton('Skip', callback_data='skip')]
task_data = TaskData()
config = self.user_config.get_user_config(update.message.from_user.username)
projects = self.jira_repository.get_projects()
options = [p.name for p in projects]
data = [p.key for p in projects]
reply_markup = self.build_keyboard(options, data, row_width=3)
query = update.callback_query
project_key = query.data
message = update.message
user_cfg = context.user_data['user_config']
last_message_id = context.user_data['last_inline_message_id']
reply_markup = self.build_component_selection_keyboard(all_components=options, selected=task_data.components)
query = update.callback_query
available_components = context.user_data.get('available_components', [])
data = query.data
last_message_id = context.user_data['last_inline_message_id']
chat_id = query.message.chat_id
message_id = query.message.message_id
user_cfg = context.user_data['user_config']
extra_buttons = [[InlineKeyboardButton('Others', callback_data='others')]]
reply_markup = self.build_keyboard(options=assignees, data=assignees, row_width=2, include_skip=True, extra_buttons=extra_buttons)
query = update.callback_query
username_query = update.message.text.strip()
matching_users = self.jira_repository.search_users(username_query)
last_message_id = context.user_data['last_inline_message_id']
query = update.callback_query
last_message_id = context.user_data['last_inline_message_id']
chat_id = query.message.chat_id
message_id = query.message.message_id
user_cfg = context.user_data['user_config']
reply_markup = self.build_keyboard(options, include_skip=True, row_width=4)
query = update.callback_query
chat_id = query.message.chat_id
message_id = query.message.message_id
user_cfg = context.user_data['user_config']
reply_markup = self.build_keyboard(options, data, include_skip=True)
query = update.callback_query
chat_id = query.message.chat_id
message_id = query.message.message_id
user_cfg = context.user_data['user_config']
reply_markup = self.build_keyboard(options, data, include_skip=True, row_width=3)
query = update.callback_query
chat_id = query.message.chat_id
message_id = query.message.message_id
user_cfg = context.user_data['user_config']
reply_markup = self.build_keyboard(options, include_skip=True, row_width=3)
query = update.callback_query
chat_id = query.message.chat_id
message_id = query.message.message_id
user_cfg = context.user_data['user_config']
reply_markup = self.build_keyboard(options, row_width=3)
query = update.callback_query
story_texts = []
story_data = []
reply_markup = self.build_keyboard(options=story_texts, data=story_data, row_width=3)
query = update.callback_query
user_cfg = context.user_data['user_config']
reply_markup = self.build_keyboard(options, include_skip=True, row_width=3)
query = update.callback_query
user_cfg = context.user_data['user_config']
days_text = [item[1] for item in self.DEADLINE_OPTIONS]
days_data = [item[0] for item in self.DEADLINE_OPTIONS]
reply_markup = self.build_keyboard(days_text, days_data, include_skip=True, row_width=3)
query = update.callback_query
user_cfg = context.user_data['user_config']
reply_markup = self.build_label_selection_keyboard(all_labels=all_labels, selected=task_data.labels)
query = update.callback_query
available_labels = context.user_data.get('available_labels', [])
data = query.data
available_labels = context.user_data.get('available_labels', [])
new_label = update.message.text.strip()
reply_markup = self.build_label_selection_keyboard(all_labels=available_labels, selected=task_data.labels)
user_cfg = context.user_data['user_config']
attachments = task_data.attachments
media_group_messages = context.user_data.setdefault('media_group_messages', {})
media_file = await media.get_file()
reply_markup = self.build_keyboard(['Yes', 'Yes, same as before', 'No'], ['yes', 'yes, same as before', 'no'], row_width=2)
msg = await message.reply_text('Do you want to create another task **with similar fields**?', reply_markup=reply_markup, parse_mode='Markdown')
query = update.callback_query
keyboard = []
row_width = 2
bottom_row = [InlineKeyboardButton('Done', callback_data='keep_done'), InlineKeyboardButton('Skip', callback_data='keep_skip')]
fields = ['project', 'sprint', 'epic', 'assignee', 'component', 'label']
reply_markup = self.build_keep_fields_keyboard(fields, [])
query = update.callback_query
data = query.data
possible_fields = context.user_data['possible_keep_fields']
selected_fields = context.user_data['selected_keep_fields']
new_data = TaskData()
data = options
row = []
row = []
row = []
text = message.text or message.caption or ''
lines = text.strip().split('\n')
attachments = task_data.attachments
msg = await update.message.reply_text('Got it! Now send me the description of the task (or type "skip" to skip).')
desc = update.message.text.strip()
options = user_cfg.component.values
jira_components = self.jira_repository.get_project_components(task_data.project_key)
options = [c.name for c in jira_components]
component_name = data.split('|', 1)[1]
reply_markup = self.build_component_selection_keyboard(all_components=available_components, selected=task_data.components)
assignees = user_cfg.assignee.values
assignees = self.jira_repository.get_assignees(task_data.project_key)
options = matching_users
extra_buttons = [[InlineKeyboardButton('Others', callback_data='others')]]
reply_markup = self.build_keyboard(options=options, data=options, row_width=2, include_skip=True, extra_buttons=extra_buttons)
options = user_cfg.priority.values
priorities = self.jira_repository.get_priorities()
options = [p.name for p in priorities]
options = user_cfg.sprint.values
data = user_cfg.sprint.values
active_and_future_sprints = [s for s in task_data.sprints if s.state in ('active', 'future')]
options = [s.name for s in active_and_future_sprints]
data = [str(s.id) for s in active_and_future_sprints]
options = user_cfg.epic_link.values
data = user_cfg.epic_link.values
options = [epic.fields.summary for epic in task_data.epics]
data = [epic.key for epic in task_data.epics]
options = user_cfg.release.values
releases = [v for v in self.jira_repository.get_project_versions(task_data.project_key) if not v.released]
options = [version.name for version in releases]
options = user_cfg.task_type.values
options = task_data.task_types
stories = self.jira_repository.get_stories_by_epic(project_key=task_data.project_key, epic_key=task_data.epic_link)
stories = self.jira_repository.get_stories_by_project(task_data.project_key)
options = user_cfg.story_point.values
options = [str(sp) for sp in self.STORY_POINTS_VALUES]
all_labels = user_cfg.labels.values
all_labels = []
label_name = data.split('|', 1)[1]
reply_markup = self.build_label_selection_keyboard(all_labels=available_labels, selected=task_data.labels)
chat_obj = await context.bot.send_message(chat_id, 'Creating your task...')
txt = update.message.text.lower()
msgs = media_group_messages.setdefault(update.message.media_group_id, [])
message = update_or_message.message
message = update_or_message
new_issue = self.jira_repository.create_task(task_data)
assignee_user_data = self.user_config.get_user_config_by_jira_username(task_data.assignee)
row = []
chunk = possible_fields[i:i + row_width]
field = data.split('|', 1)[1]
reply_markup = self.build_keep_fields_keyboard(possible_fields, selected_fields)
mark = '✔' if comp in selected else ''
btn_text = f'{comp} {mark}'
mark = '✔' if lbl in selected else ''
btn_text = f'{lbl} {mark}'
day_offset = int(query.data)
target_date = datetime.date.today() + datetime.timedelta(days=day_offset)
date_str = target_date.strftime('%Y-%m-%d')
buffer = BytesIO(await response.read())
new_data = old_data.model_copy()
mark = '✔' if field in selected_fields else ''
btn_text = f'{field} {mark}'

__main__ Section:


Classes and Methods:
Class: JiraTaskCreation
  __init__ (self: Any, jira_repository: TaskManagerRepositoryInterface, user_config: UserConfigInterface) -> None
  build_keyboard (self: Any, options: List[str], data: Optional[List[str]], include_skip: bool, row_width: int, extra_buttons: Optional[List[List[InlineKeyboardButton]]]) -> InlineKeyboardMarkup
  build_component_selection_keyboard (self: Any, all_components: List[str], selected: List[str]) -> InlineKeyboardMarkup
  build_label_selection_keyboard (self: Any, all_labels: List[str], selected: List[str]) -> InlineKeyboardMarkup
  start (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: jira_repository.get_projects, user_config.get_user_config
  select_project (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: jira_repository.get_board_id, jira_repository.get_epics, jira_repository.get_issue_types_for_project, jira_repository.get_sprints
  add_summary (self: Any, update: Update, context: CallbackContext) -> int
  add_description (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: jira_repository.get_project_components
  toggle_component_selection (self: Any, update: Update, context: CallbackContext) -> int
  ask_assignee_from_text (self: Any, update: Update, context: CallbackContext) -> int
  ask_assignee (self: Any, query: CallbackQuery, context: CallbackContext) -> int
  _ask_assignee_common (self: Any, context: CallbackContext, chat_id: int, message_id: int) -> int
      calls on dependencies: jira_repository.get_assignees
  add_assignee (self: Any, update: Update, context: CallbackContext) -> int
  search_assignee (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: jira_repository.search_users
  select_assignee_from_search (self: Any, update: Update, context: CallbackContext) -> int
  ask_priority_from_text (self: Any, update: Update, context: CallbackContext) -> int
  ask_priority_from_text_internal (self: Any, context: CallbackContext, chat_id: int, message_id: int) -> int
  ask_priority_from_query (self: Any, query: CallbackQuery, context: CallbackContext) -> int
  _ask_priority_common (self: Any, context: CallbackContext, chat_id: int, message_id: int) -> int
      calls on dependencies: jira_repository.get_priorities
  add_priority (self: Any, update: Update, context: CallbackContext) -> int
  ask_sprint (self: Any, query: CallbackQuery, context: CallbackContext) -> int
  _ask_sprint_common (self: Any, context: CallbackContext, chat_id: int, message_id: int) -> int
  add_sprint (self: Any, update: Update, context: CallbackContext) -> int
  ask_epic_from_query (self: Any, query: CallbackQuery, context: CallbackContext) -> int
  _ask_epic_common (self: Any, context: CallbackContext, chat_id: int, message_id: int) -> int
  add_epic (self: Any, update: Update, context: CallbackContext) -> int
  ask_release_from_query (self: Any, query: CallbackQuery, context: CallbackContext) -> int
  _ask_release_common (self: Any, context: CallbackContext, chat_id: int, message_id: int) -> int
      calls on dependencies: jira_repository.get_project_versions
  add_release (self: Any, update: Update, context: CallbackContext) -> int
  ask_task_type_from_query (self: Any, query: CallbackQuery, context: CallbackContext) -> int
  _ask_task_type_common (self: Any, context: CallbackContext, chat_id: int, message_id: int) -> int
  add_task_type (self: Any, update: Update, context: CallbackContext) -> int
  _maybe_ask_for_subtask_story (self: Any, context: CallbackContext, chat_id: int, message_id: int) -> int
  ask_subtask_story (self: Any, chat_id: int, message_id: int, context: CallbackContext) -> int
      calls on dependencies: jira_repository.get_stories_by_epic, jira_repository.get_stories_by_project
  add_subtask_story (self: Any, update: Update, context: CallbackContext) -> int
  _ask_story_points_common (self: Any, context: CallbackContext, chat_id: int, message_id: int) -> int
  add_story_points (self: Any, update: Update, context: CallbackContext) -> int
  _ask_deadline_common (self: Any, context: CallbackContext, chat_id: int, message_id: int) -> int
  add_deadline (self: Any, update: Update, context: CallbackContext) -> int
  _ask_labels_common (self: Any, context: CallbackContext, chat_id: int, message_id: int) -> int
  toggle_label_selection (self: Any, update: Update, context: CallbackContext) -> int
  add_new_label (self: Any, update: Update, context: CallbackContext) -> int
  _ask_attachment_prompt (self: Any, context: CallbackContext, chat_id: int, message_id: int) -> int
  add_attachment (self: Any, update: Update, context: CallbackContext) -> int
  process_media_group (self: Any, messages: List[Any], attachments: Dict[str, List]) -> None
  process_single_media (self: Any, message: Any, attachments: Dict[str, List]) -> None
  fetch_and_store_media (self: Any, media: Any, session: Any, storage_list: Any, filename: Any) -> None
  finalize_task (self: Any, update_or_message: Any, context: CallbackContext) -> None
      calls on dependencies: jira_repository.create_task, user_config.get_user_config_by_jira_username
  handle_create_another (self: Any, update: Update, context: CallbackContext) -> int
  build_keep_fields_keyboard (self: Any, possible_fields: List[str], selected_fields: List[str]) -> InlineKeyboardMarkup
  ask_keep_fields (self: Any, update: Update, context: CallbackContext) -> int
  toggle_keep_field_selection (self: Any, update: Update, context: CallbackContext) -> int
  _setup_new_task_with_kept_fields (self: Any, query: CallbackQuery, context: CallbackContext, selected_fields: List[str]) -> int


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/use_cases/telegram_commands/transition_task.py
================================================================================

Imports:
from __future__ import annotations
from jira import JIRA
from telegram import InlineKeyboardButton
from telegram import InlineKeyboardMarkup
from telegram import Update
from telegram.ext import CallbackContext
from telegram.ext import ConversationHandler
from jira_telegram_bot import LOGGER
from jira_telegram_bot.settings import JIRA_BOARD_SETTINGS

Global Initiations:
keyboard = [[InlineKeyboardButton(item, callback_data=item) for item in items[i:i + row_size]] for i in range(0, len(items), row_size)]
keyboard = self.build_inline_keyboard(self.assignees, row_size=2)
query = update.callback_query
assignee = query.data
issues = self.jira.search_issues(f'assignee="{assignee}" AND project="{self.jira.project(JIRA_BOARD_SETTINGS.board_name)}"')
keyboard = [[InlineKeyboardButton(f'{issue.key} - {issue.fields.summary} (Priority: {issue.fields.priority.name})', callback_data=issue.key)] for issue in issues]
reply_markup = InlineKeyboardMarkup(keyboard)
query = update.callback_query
task_key = query.data
issue = self.jira.issue(task_key)
description = issue.fields.description or 'No description provided'
message = f'Task: {task_key}\nSummary: {issue.fields.summary}\nDescription: {description}\nStatus: {issue.fields.status.name}'
keyboard = [[InlineKeyboardButton('Continue', callback_data='continue')], [InlineKeyboardButton('Return', callback_data='return')], [InlineKeyboardButton('Cancel', callback_data='cancel')]]
reply_markup = InlineKeyboardMarkup(keyboard)
query = update.callback_query
issue = context.user_data.get('selected_task')
transitions = self.jira.transitions(issue)
transition_id = next((t['id'] for t in transitions if t['name'] == 'In Progress'))

__main__ Section:


Classes and Methods:
Class: JiraTaskTransition
  __init__ (self: Any, jira: JIRA) -> None
  build_inline_keyboard (self: Any, items: Any, row_size: Any) -> None
  start_transition (self: Any, update: Update, context: CallbackContext) -> int
  select_assignee (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: jira.project, jira.search_issues
  show_task_details (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: jira.issue
  handle_task_action (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: jira.transition_issue, jira.transitions


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/adapters/services/__init__.py
================================================================================

Imports:
from __future__ import annotations

Global Initiations:


__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/adapters/repositories/__init__.py
================================================================================

Imports:


Global Initiations:


__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/adapters/utils/change_priority_schema.py
================================================================================

Imports:
from __future__ import annotations
from typing import Dict
from typing import List
from jira import Issue
from jira.exceptions import JIRAError
from jira_telegram_bot import LOGGER
from jira_telegram_bot.adapters.repositories.jira.jira_server_repository import JiraRepository

Global Initiations:
PROJECT_KEY = 'PARSCHAT'
MAX_RESULTS = 1000
BATCH_LOG_EVERY = 20
id_by_name = {}
target_name_to_id = _build_target_priority_id_map(repo)
missing = [name for name in PRIORITY_REMAP.values() if name.lower() not in target_name_to_id]
jql = f'project = "{project_key}"'
repo = JiraRepository()
old_prio_obj = issue.fields.priority
new_prio_name = PRIORITY_REMAP.get(old_prio_obj.name)

__main__ Section:
if __name__ == '__main__':
    repo = JiraRepository()
    update_priorities_for_board(repo, PROJECT_KEY)

Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/adapters/ai_models/__init__.py
================================================================================

Imports:


Global Initiations:


__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/adapters/ai_models/openai_model.py
================================================================================

Imports:
from __future__ import annotations
from langchain_openai import ChatOpenAI
from jira_telegram_bot.settings import OPENAI_SETTINGS
from jira_telegram_bot.use_cases.interface.openai_gateway_interface import OpenAIGatewayInterface

Global Initiations:
llm = ChatOpenAI(model_name='gpt-4o-mini', openai_api_key=self.api_key, temperature=self.temperature)

__main__ Section:


Classes and Methods:
Class: OpenAIGateway
  __init__ (self: Any) -> None
  get_llm (self: Any) -> ChatOpenAI


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/adapters/ai_models/speech_processor.py
================================================================================

Imports:
from __future__ import annotations
import os
from typing import Optional
from loguru import logger
from openai import AsyncOpenAI
from jira_telegram_bot.entities.speech import TranscriptionResult
from jira_telegram_bot.settings import OPENAI_SETTINGS
from jira_telegram_bot.use_cases.interface.speech_processor_interface import SpeechProcessorInterface

Global Initiations:
persian_chars = len([c for c in text if '\u0600' <= c <= 'ۿ'])
mp3_path = voice_file_path
text = await self.transcribe_audio(mp3_path)
is_persian = self.is_persian(text)
confidence = 0.95
response = await self.client.chat.completions.create(model='gpt-4', messages=[{'role': 'system', 'content': 'You are a Persian to English translator specializing in technical content. Preserve programming terms, API names, and technical concepts in their original form. Maintain the original meaning while making it natural in English.'}, {'role': 'user', 'content': text}], temperature=0.3)
response = await self.client.audio.transcriptions.create(model=self.model, file=audio_file, language=language, response_format='text', prompt='This is a tech conversation potentially containing programming terms, API names, and technical concepts.')
translation = await self.translate_to_english(text)
translation = None

__main__ Section:


Classes and Methods:
Class: SpeechProcessor
  __init__ (self: Any) -> None
  convert_audio_format (self: Any, input_path: str, target_format: str) -> str
  transcribe_audio (self: Any, audio_path: str, language: Optional[str]) -> str
      calls on dependencies: client.audio.transcriptions.create
  process_voice_message (self: Any, voice_file_path: str) -> TranscriptionResult
  translate_to_english (self: Any, text: str) -> str
      calls on dependencies: client.chat.completions.create
  is_persian (text: str) -> bool


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/adapters/gateways/__init__.py
================================================================================

Imports:


Global Initiations:


__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/adapters/services/telegram/authentication.py
================================================================================

Imports:
from telegram import Update
from jira_telegram_bot import LOGGER
from jira_telegram_bot.settings import TELEGRAM_SETTINGS

Global Initiations:
user_id = update.message.from_user.username
chat_type = update.message.chat.type

__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/adapters/services/telegram/__init__.py
================================================================================

Imports:
from __future__ import annotations
import requests
from jira_telegram_bot.settings import TELEGRAM_SETTINGS

Global Initiations:
url = f'https://api.telegram.org/bot{TELEGRAM_SETTINGS.HOOK_TOKEN}/getFile?file_id={self.file_id}'
resp = requests.get(url)
result = resp.json()['result']

__main__ Section:


Classes and Methods:
Class: MockTelegramPhoto
  __init__ (self: Any, file_id: Any) -> None
  get_file (self: Any) -> None
Class: MockTelegramDocument
Class: MockTelegramVideo
Class: MockTelegramAudio
Class: MockFilePath
  __init__ (self: Any, file_id: Any) -> None
  _get_file_path (self: Any) -> str


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/adapters/services/telegram/telegram_gateway.py
================================================================================

Imports:
from __future__ import annotations
from io import BytesIO
from typing import Optional, Any, List
import aiohttp
import requests
from jira_telegram_bot import LOGGER
from jira_telegram_bot.settings import TELEGRAM_WEBHOOK_SETTINGS, TELEGRAM_SETTINGS
from jira_telegram_bot.use_cases.interface.telegram_gateway_interface import TelegramGatewayInterface

Global Initiations:
url = f'https://api.telegram.org/bot{TELEGRAM_SETTINGS.HOOK_TOKEN}/sendMessage'
payload = {'chat_id': chat_id, 'text': text, 'parse_mode': parse_mode}
resp = requests.post(url, json=payload)
media_file = await media.get_file()
file_url = f'https://api.telegram.org/file/bot{TELEGRAM_SETTINGS.HOOK_TOKEN}/{media_file.file_path}'
url = f'{self.base_url}/sendMessage'
payload = {'chat_id': chat_id, 'text': text, 'parse_mode': parse_mode}
resp = requests.post(url, json=payload)
buffer = BytesIO(await response.read())

__main__ Section:


Classes and Methods:
Class: TelegramGateway
  __init__ (self: Any) -> None
  send_message (self: Any, chat_id: int, text: str, reply_message_id: Optional[int], parse_mode: str) -> None


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/adapters/repositories/file_storage/__init__.py
================================================================================

Imports:
from __future__ import annotations
import json
import os
import time
from typing import Any
from typing import Dict
from typing import Optional
from jira_telegram_bot import DEFAULT_PATH

Global Initiations:
DATA_STORE_PATH = f'{DEFAULT_PATH}/data_store.json'
data = self.load_data_store()
created_at = message_data.get('date', int(time.time()))
from_user = message_data.get('from', {})
message_type = 'channel_post'
data = self.load_data_store()
data = self.load_data_store()
data_store = self.load_data_store()
data_store = self.load_data_store()
content_type = 'photo'
content_type = 'video'
content_type = 'document'
content_type = 'audio'
content_type = 'text'

__main__ Section:


Classes and Methods:
Class: TelegramPostDataStore
  __init__ (self: Any, data_store_path: str) -> None
  load_data_store (self: Any) -> Dict[str, Any]
  save_data_store (self: Any, data: Dict[str, Any]) -> None
  save_mapping (self: Any, channel_post_id: int, issue_key: str, channel_chat_id: int, group_id: int, message_data: Dict[str, Any]) -> None
  get_issue_key_from_channel_post (self: Any, channel_post_id: int) -> Optional[str]
  get_group_chat_id_from_channel_post (self: Any, channel_post_id: int) -> Optional[int]
  find_issue_key_for_group (self: Any, chat_id: int) -> Optional[str]
  find_issue_key_from_message_id (self: Any, message_id: int) -> Optional[str]
  find_group_chat_by_issue (self: Any, data_store: Dict[str, Any], issue_key: str) -> Optional[Dict[str, Any]]
  find_channel_post_by_issue (self: Any, data_store: Dict[str, Any], issue_key: str) -> Optional[Dict[str, Any]]


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/adapters/repositories/postgres/__init__.py
================================================================================

Imports:


Global Initiations:


__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/adapters/repositories/jira/__init__.py
================================================================================

Imports:


Global Initiations:


__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/adapters/repositories/jira/jira_server_repository.py
================================================================================

Imports:
from __future__ import annotations
import json
import os
import time
from typing import Dict
from typing import List
from typing import Optional
from jira import Issue
from jira import JIRA
from jira_telegram_bot import DEFAULT_PATH
from jira_telegram_bot import LOGGER
from jira_telegram_bot.entities.task import TaskData
from jira_telegram_bot.settings import JIRA_SETTINGS
from jira_telegram_bot.settings.jira_board_config import JiraBoardSettings
from jira_telegram_bot.use_cases.interface.task_manager_repository_interface import TaskManagerRepositoryInterface

Global Initiations:
entry = self.cache.get(cache_key)
cache_key = ('get_projects', None)
result = self._get_from_cache(cache_key, 48 * 3600)
result = self.jira.projects()
cache_key = ('get_epics', project_key)
result = self._get_from_cache(cache_key, 72 * 3600)
result = self.jira.search_issues(f'project="{project_key}" AND issuetype=Epic AND status in ("To Do", "In Progress")')
cache_key = ('get_board_id', project_key)
result = self._get_from_cache(cache_key, 48 * 3600)
boards = self.jira.boards()
cache_key = ('get_sprints', board_id)
result = self._get_from_cache(cache_key, 8 * 3600)
cache_key = ('get_project_versions', project_key)
result = self._get_from_cache(cache_key, 2 * 86400)
result = self.jira.project_versions(project_key)
cache_key = ('issue_types_for_project', project_key)
result = self._get_from_cache(cache_key, 4 * 3600)
result = [issue_type.name for issue_type in self.jira.issue_types_for_project(project_key)]
cache_key = 'priorities'
result = self._get_from_cache(cache_key, 1200 * 3600)
result = self.jira.priorities()
cache_key = ('search_users', username)
result = self._get_from_cache(cache_key, 1 * 3600)
users = self.jira.search_users(username, maxResults=50)
user_list = [user.name for user in users]
all_issues = []
block_size = 100
block_num = 0
query = f'issue in linkedIssues("{epic_key}") OR "Epic Link" = {epic_key} AND project = "{project_key}" AND issuetype = Story'
query = f'project = "{project_key}" AND issuetype = Story'
issue_fields = {'project': {'key': task_data.project_key}, 'summary': task_data.summary, 'description': task_data.description or 'No Description Provided', 'issuetype': {'name': task_data.task_type or 'Task'}}
issue_fields = self.build_issue_fields(task_data)
new_issue = self.create_issue(issue_fields)
transitions = self.jira.transitions(issue_key)
fields = self.build_issue_fields(task_data)
issue = self.jira.issue(issue_key)
issue = self.jira.issue(issue_key)
result = self.jira.sprints(board_id=board_id)
result = []
cache_key = ('get_assignees', project_key)
result = self._get_from_cache(cache_key, 2 * 3600)
assignees = set()
recent_issues = self.jira.search_issues(f'project = {project_key} AND createdDate > startOfMonth(-1)')
assignee_list = sorted(assignees) if assignees else []
start_idx = block_num * block_size
issues_block = self.jira.search_issues(query, startAt=start_idx, maxResults=block_size)
sprint_name = 'kanban'
last_sprint_of_task = getattr(issue.fields, self.jira_sprint_id)[-1] if getattr(issue.fields, self.jira_sprint_id) else None
sprint_name = None
filepath = os.path.join(DEFAULT_PATH, 'jira_telegram_bot/settings/project_labels.json')
labels = set()
label_list = sorted(list(labels))
filepath = os.path.join(DEFAULT_PATH, 'jira_telegram_bot/settings/project_labels.json')
data = {}
issue = self.jira.issue(issue_key)
name_position = last_sprint_of_task.find('name=')
sprint_name = last_sprint_of_task[name_position:].split(',')[0].strip('name=')
issues = self.jira.search_issues(f'project = "{project_key}"', maxResults=1000)
data = json.load(f)
data = json.load(f)

__main__ Section:


Classes and Methods:
Class: JiraRepository
  __init__ (self: Any, settings: JiraBoardSettings) -> None
  _get_from_cache (self: Any, cache_key: Any, max_age_seconds: Any) -> None
  _set_cache (self: Any, cache_key: Any, result: Any) -> None
  get_projects (self: Any) -> None
      calls on dependencies: jira.projects
  get_project_components (self: Any, project_key: Any) -> None
      calls on dependencies: jira.project_components
  get_epics (self: Any, project_key: str) -> None
      calls on dependencies: jira.search_issues
  get_board_id (self: Any, project_key: str) -> Optional[int]
      calls on dependencies: jira.boards
  get_sprints (self: Any, board_id: Any) -> None
      calls on dependencies: jira.sprints
  get_project_versions (self: Any, project_key: Any) -> None
      calls on dependencies: jira.project_versions
  get_issue_types_for_project (self: Any, project_key: Any) -> None
      calls on dependencies: jira.issue_types_for_project
  get_priorities (self: Any) -> None
      calls on dependencies: jira.priorities
  get_assignees (self: Any, project_key: str) -> List[str]
      calls on dependencies: jira.search_issues
  search_users (self: Any, username: str) -> List[str]
      calls on dependencies: jira.search_users
  search_for_issues (self: Any, query: str, max_results: int) -> List[Issue]
      calls on dependencies: jira.search_issues
  get_stories_by_epic (self: Any, epic_key: str, project_key: str) -> List[Issue]
  get_stories_by_project (self: Any, project_key: str, epic_link: str, status: str) -> List[Issue]
  build_issue_fields (self: Any, task_data: TaskData) -> dict
  build_task_data_from_issue (self: Any, issue: Issue) -> TaskData
  handle_attachments (self: Any, issue: Issue, attachments: Dict[str, List]) -> None
  create_issue (self: Any, fields: Any) -> None
      calls on dependencies: jira.create_issue
  add_attachment (self: Any, issue: Any, attachment: Any, filename: Any) -> None
      calls on dependencies: jira.add_attachment
  create_task (self: Any, task_data: TaskData) -> Issue
  add_comment (self: Any, issue_key: str, comment: str) -> None
      calls on dependencies: jira.add_comment
  create_task_data_from_jira_issue (self: Any, issue: Any) -> TaskData
  get_labels (self: Any, project_key: str) -> List[str]
      calls on dependencies: jira.search_issues
  set_labels (self: Any, project_key: str, labels: List[str]) -> bool
  transition_task (self: Any, issue_key: str, status: str) -> None
      calls on dependencies: jira.transition_issue, jira.transitions
  assign_issue (self: Any, issue_key: str, assignee: str) -> None
      calls on dependencies: jira.assign_issue
  update_issue (self: Any, issue_key: str, task_data: TaskData) -> None
      calls on dependencies: jira.issue
  update_issue_from_fields (self: Any, issue_key: str, fields: dict) -> None
      calls on dependencies: jira.issue
  get_issue (self: Any, issue_key: str) -> Optional[Issue]
      calls on dependencies: jira.issue


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/frameworks/fast_api/jira_webhook_controller.py
================================================================================

Imports:
from __future__ import annotations
from fastapi import APIRouter
from fastapi import Depends
from fastapi import Request
from lagom import Context
from jira_telegram_bot.use_cases.handle_jira_webhook_usecase import HandleJiraWebhookUseCase

Global Initiations:
router = APIRouter()
body = await request.json()
result = handle_jira_uc.run(body)

__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/frameworks/fast_api/create_ticket_controller.py
================================================================================

Imports:
from __future__ import annotations
from fastapi import FastAPI
from jira_telegram_bot.app_container import create_fastapi_integration
from jira_telegram_bot.frameworks.fast_api.telegram_webhook_controller import get_telegram_router

Global Initiations:
app = FastAPI()
deps = create_fastapi_integration()

__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/frameworks/fast_api/__init__.py
================================================================================

Imports:


Global Initiations:


__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/frameworks/fast_api/telegram_webhook_controller.py
================================================================================

Imports:
from __future__ import annotations
from fastapi import APIRouter
from fastapi import Depends
from fastapi import Request
from jira_telegram_bot import LOGGER
from jira_telegram_bot.settings import JIRA_SETTINGS
from jira_telegram_bot.use_cases.create_task_usecase import CreateTaskUseCase
from jira_telegram_bot.use_cases.interface.task_manager_repository_interface import TaskManagerRepositoryInterface
from jira_telegram_bot.use_cases.interface.telegram_gateway_interface import TelegramGatewayInterface
from jira_telegram_bot.use_cases.ai_agents.parse_jira_prompt_usecase import ParseJiraPromptUseCase
from jira_telegram_bot.utils.data_store import get_issue_key_from_channel_post
from jira_telegram_bot.utils.data_store import save_comment
from jira_telegram_bot.utils.data_store import save_mapping

Global Initiations:
router = APIRouter()
data = await request.json()
channel_post = data['channel_post']
text = channel_post.get('text') or channel_post.get('caption') or ''
parsed_data = parse_prompt_uc.run(text)
issue = create_task_uc.run(project_key='PCT', summary=parsed_data['summary'], description=parsed_data['description'], task_type=parsed_data['task_type'], labels=[parsed_data.get('labels', '')], assignee=None)
parent_msg_id = channel_post['reply_to_message']['message_id']
issue_key = get_issue_key_from_channel_post(parent_msg_id)

__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/frameworks/fast_api/create_ticket.py
================================================================================

Imports:
from __future__ import annotations
import asyncio
import time
from collections import defaultdict
from typing import Any
from typing import Dict
from typing import List
import aiohttp
import jdatetime
import requests
import uvicorn
from fastapi import FastAPI
from fastapi import Request
from jira_telegram_bot import LOGGER
from jira_telegram_bot.adapters.repositories.file_storage import TelegramPostDataStore
from jira_telegram_bot.adapters.repositories.jira.jira_server_repository import JiraRepository
from jira_telegram_bot.adapters.services.telegram import MockTelegramAudio
from jira_telegram_bot.adapters.services.telegram import MockTelegramDocument
from jira_telegram_bot.adapters.services.telegram import MockTelegramPhoto
from jira_telegram_bot.adapters.services.telegram import MockTelegramVideo
from jira_telegram_bot.adapters.services.telegram.telegram_gateway import fetch_and_store_media
from jira_telegram_bot.adapters.services.telegram.telegram_gateway import send_telegram_message
from jira_telegram_bot.adapters.user_config import UserConfig
from jira_telegram_bot.entities.task import TaskData
from jira_telegram_bot.settings import JIRA_SETTINGS
from jira_telegram_bot.settings import TELEGRAM_SETTINGS
from jira_telegram_bot.use_cases.ai_agents.create_ticketing_issue import parse_jira_prompt

Global Initiations:
app = FastAPI()
telegram_post_data_store = TelegramPostDataStore()
jira_repository = JiraRepository(JIRA_SETTINGS)
user_config = UserConfig()
JIRA_PROJECT_KEY = 'PCT'
GROUP_TIMEOUT_SECONDS = 5.0
attachments = task_data.attachments
issue = jira_repository.create_task(task_data)
issue_message = f'Task created (media group) successfully! Link: {JIRA_SETTINGS.domain}/browse/{issue.key}'
post = telegram_post_data_store.load_data_store()[str(messages[-1]['message_id'])]
group_chat_id = post['group_chat_id']
data_store = telegram_post_data_store.load_data_store()
attachments = task_data.attachments
issue = jira_repository.create_task(task_data)
issue_message = f'Task created (single) successfully! Link: {JIRA_SETTINGS.domain}/browse/{issue.key}'
chat_id = channel_post['chat']['id']
channel_post_id = channel_post['message_id']
comment = body.get('comment', {})
comment_body = comment.get('body', '')
jira_username = comment.get('author', {}).get('name', 'UnknownUser')
telegram_username = user_config.get_user_config_by_jira_username(jira_username).telegram_username
comment_content = f'Comment from [@{telegram_username}] :\n\n{comment_body}'
message = f'*💬 Comment Added*\n\nTask {issue_key} has a new comment: {comment_content}'
old_status = item.get('fromString')
new_status = item.get('toString')
message = f"*📊 Status Update *\n\nTask {issue_key} moved from *'{old_status}'* to *'{new_status}'*"
creator_username = user_data.get('metadata', {}).get('creator_username')
assignee = user_config.get_user_config(creator_username).jira_username
notify_msg = f'*👤 Task Reassigned*\n\nTask {issue_key} has been assigned to @{creator_username} for review'
old_date = item.get('fromString', 'not set')
new_date = item.get('toString', 'not set')
time = date_str.split(' ')[1]
georgian_time = jdatetime.GregorianToJalali(int(year), int(month), int(day))
username = channel_post.get('from', {}).get('username', 'UnknownUser')
text = channel_post.get('text') or channel_post.get('caption') or ''
parsed_fields = parse_jira_prompt(text)
task_data = create_task_data(username, parsed_fields)
media_group_id = channel_post.get('media_group_id')
issue = jira_repository.create_task(task_data)
issue_message = f'Task created (text-only) successfully! Link: {JIRA_SETTINGS.domain}/browse/{issue.key}'
chat_id = channel_post['chat']['id']
channel_post_id = channel_post['message_id']
message_id = message['message_id']
forward_origin = message.get('forward_origin', {})
original_message_id = forward_origin.get('message_id')
issue_key = telegram_post_data_store.get_issue_key_from_channel_post(original_message_id)
group_chat_id = message['chat']['id']
chat_id = message['chat']['id']
message_from = message.get('from', {}).get('username', 'UnknownUser')
text = message.get('text') or message.get('caption') or ''
jira_username = user_config.get_user_config(message_from).jira_username
command_result = await process_command(text, issue_key, message_from, jira_username)
url = f'https://api.telegram.org/bot{TELEGRAM_SETTINGS.HOOK_TOKEN}/deleteWebhook'
url = f'https://api.telegram.org/bot{TELEGRAM_SETTINGS.HOOK_TOKEN}/deleteWebhook'
response = requests.get(url)
url = f'https://api.telegram.org/bot{TELEGRAM_SETTINGS.HOOK_TOKEN}/setWebhook'
payload = {'url': TELEGRAM_SETTINGS.WEBHOOK_URL, 'max_connections': 100, 'drop_pending_updates': True}
response = requests.post(url, json=payload)
formatted_date = format_jalali_date(new_date)
message = f'*📅 Due Date Set*\n\nTask {issue_key} is due on *{formatted_date}*'
data_store = telegram_post_data_store.load_data_store()
store_entry = telegram_post_data_store.find_channel_post_by_issue(issue_key)
body = await request.json()
issue_key = body.get('issue', {}).get('key')
data_store = telegram_post_data_store.load_data_store()
group_chat_info = telegram_post_data_store.find_group_chat_by_issue(data_store, issue_key)
group_chat_id = group_chat_info['group_chat_id']
reply_message_id = group_chat_info['reply_message_id']
changelog = body.get('changelog', {}).get('items', [])
issue_link = f'{JIRA_SETTINGS.domain}/browse/{issue_key}'
issue_message = f'Jira Issue Created:\nLink: {issue_link}'
data_local = telegram_post_data_store.load_data_store()
issue_key = telegram_post_data_store.find_issue_key_from_message_id(f'{message['reply_to_message']['forward_from_message_id']}')
formatted_comment = f'h6. Comment from [~{jira_username}] :\n\n{text}'
data = await request.json()
now = time.time()
to_finalize = []
photo_array = channel_post['photo']
file_id = photo_array[-1]['file_id']
mock_media = MockTelegramPhoto(file_id)
formatted_old_date = format_jalali_date(old_date.split(' ')[0])
message = f'*📅 Due Date Removed*\n\nTask {issue_key} due date has been cleared (was: {formatted_old_date})'
message = f'*📅 Due Date Cleared*\n\nTask {issue_key} due date has been cleared'
issue = jira_repository.jira.issue(issue_key)
field = item.get('field')
entry = data_local[str(original_message_id)]
photo_array = msg['photo']
file_info = photo_array[-1]
file_id = file_info['file_id']
mock_media = MockTelegramPhoto(file_id)
doc = channel_post['document']
file_id = doc['file_id']
file_name = doc.get('file_name', 'single_document')
mock_media = MockTelegramDocument(file_id)
messages = MEDIA_GROUP_STORE.pop(group_id, [])
first_message = messages[0]
username = first_message.get('from', {}).get('username', 'UnknownUser')
text = first_message.get('text') or first_message.get('caption') or ''
parsed_fields = parse_jira_prompt(text)
task_data = TaskData(project_key=JIRA_PROJECT_KEY, summary=parsed_fields['summary'], description=parsed_fields['description'], task_type=parsed_fields['task_type'], assignee=user_config.get_user_config(username).jira_username)
doc = msg['document']
file_id = doc['file_id']
file_name = doc.get('file_name', f'document_{idx}')
mock_media = MockTelegramDocument(file_id)
vid = channel_post['video']
file_id = vid['file_id']
mock_media = MockTelegramVideo(file_id)
vid = msg['video']
file_id = vid['file_id']
mock_media = MockTelegramVideo(file_id)
aud = channel_post['audio']
file_id = aud['file_id']
mock_media = MockTelegramAudio(file_id)
assignee = item.get('toString')
assignee = jira_repository.jira.issue(issue_key).fields.assignee.name
telegram_username = user_config.get_user_config_by_jira_username(assignee).telegram_username
aud = msg['audio']
file_id = aud['file_id']
mock_media = MockTelegramAudio(file_id)
message = f'<b>👤Task Assigned</b>\n\nTask has been assigned to @{telegram_username}'

__main__ Section:
if __name__ == '__main__':
    uvicorn.run(app, host='0.0.0.0', port=2315)

Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/frameworks/telegram/task_get_users_time_handler.py
================================================================================

Imports:
from __future__ import annotations
from telegram.ext import CommandHandler
from telegram.ext import ConversationHandler
from telegram.ext import filters
from telegram.ext import MessageHandler
from jira_telegram_bot.use_cases.interface.task_handler_interface import TaskHandlerInterface
from jira_telegram_bot.use_cases.telegram_commands.task_get_users_time import TaskGetUsersTime

Global Initiations:


__main__ Section:


Classes and Methods:
Class: TaskGetUsersTimeHandler
  __init__ (self: Any, task_get_users_time_use_case: TaskGetUsersTime) -> None
  get_handler (self: Any) -> ConversationHandler
  cancel (self: Any, update: Any, context: Any) -> None


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/frameworks/telegram/voice.py
================================================================================

Imports:
from __future__ import annotations
import logging
from langchain import LLMChain
from langchain.prompts import PromptTemplate
from telegram import InlineKeyboardButton
from telegram import InlineKeyboardMarkup
from telegram import Update
from telegram import Voice
from telegram.ext import CallbackContext
from telegram.ext import CallbackQueryHandler
from telegram.ext import CommandHandler
from telegram.ext import ConversationHandler
from telegram.ext import filters
from telegram.ext import MessageHandler
from jira_telegram_bot.adapters.ai_models.openai_model import OpenAIGateway
from jira_telegram_bot.use_cases.interface.task_handler_interface import TaskHandlerInterface
from jira_telegram_bot.use_cases.interface.task_manager_repository_interface import TaskManagerRepositoryInterface
from jira_telegram_bot.use_cases.interface.user_config_interface import UserConfigInterface

Global Initiations:
LOGGER = logging.getLogger(__name__)
conv_handler = ConversationHandler(entry_points=[CommandHandler('voice_report', self.start)], states={SELECT_PROJECT: [CallbackQueryHandler(self.select_project_callback)], SELECT_TASKS: [CallbackQueryHandler(self.select_tasks_callback)], WAIT_FOR_VOICE: [MessageHandler(filters.VOICE, self.handle_voice_message)], CONFIRM_POST: [CallbackQueryHandler(self.handle_confirm_post)]}, fallbacks=[CommandHandler('cancel', self.cancel)], allow_reentry=True)
user_telegram = update.effective_user.username
user_cfg = self.user_config_repo.get_user_config(user_telegram)
default_project_key = user_cfg.project or None
projects = self.jira_repo.get_projects()
query = update.callback_query
project_key = query.data
user_telegram = update.effective_user.username
user_cfg = self.user_config_repo.get_user_config(user_telegram)
jira_username = user_cfg.jira_username or user_telegram
project_key = context.user_data['selected_project']
jql = f'assignee="{jira_username}" AND project="{project_key}" AND statusCategory != Done order by created DESC'
issues = self.jira_repo.jira.search_issues(jql, maxResults=20)
keyboard = []
query = update.callback_query
file_id = voice_msg.file_id
file_obj = update.message.bot.get_file(file_id)
file_content = file_obj.download_as_bytearray()
raw_transcript = self.openai.transcribe_audio(audio_content=file_content, model='o3-mini', language='fa')
cleaned_text = self.openai.clean_text(raw_transcript, model='o3-mini')
keyboard = [[InlineKeyboardButton('بله، ثبت شود', callback_data='confirm_post'), InlineKeyboardButton('خیر، انصراف', callback_data='cancel')]]
query = update.callback_query
keyboard = []
button_text = f'{issue.key} - {issue.fields.summary}'
selected_set = context.user_data['report_task_keys']
transcribed_text = context.user_data.get('transcribed_text', '')
selected_task_keys = list(context.user_data['report_task_keys'])
tasks_formatted = []
task_list_str = '\n'.join(tasks_formatted)
final_persian_report = self.summary_chain.run(transcribed_text=transcribed_text, task_list=task_list_str)
issue = self.jira_repo.jira.issue(k)

__main__ Section:


Classes and Methods:
Class: VoiceReportHandler
  __init__ (self: Any, user_config_repo: UserConfigInterface, jira_repo: TaskManagerRepositoryInterface, openai_gateway: OpenAIGateway) -> None
      calls on dependencies: openai.get_llm
  get_handler (self: Any) -> None
  start (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: jira_repo.get_projects, user_config_repo.get_user_config
  select_project_callback (self: Any, update: Update, context: CallbackContext) -> int
  _ask_for_tasks (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: jira_repo.jira.search_issues, user_config_repo.get_user_config
  select_tasks_callback (self: Any, update: Update, context: CallbackContext) -> int
  handle_voice_message (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: openai.clean_text, openai.transcribe_audio
  handle_confirm_post (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: jira_repo.add_comment, jira_repo.jira.issue, summary_chain.run
  cancel (self: Any, update: Update, context: CallbackContext) -> int


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/frameworks/telegram/advanced_task_creation_handler.py
================================================================================

Imports:
from __future__ import annotations
import json
import os
import tempfile
from telegram import InlineKeyboardButton
from telegram import InlineKeyboardMarkup
from telegram import Update
from telegram.ext import CallbackContext
from telegram.ext import CallbackQueryHandler
from telegram.ext import CommandHandler
from telegram.ext import ConversationHandler
from telegram.ext import filters
from telegram.ext import MessageHandler
from jira_telegram_bot import DEFAULT_PATH
from jira_telegram_bot import LOGGER
from jira_telegram_bot.entities.speech import TranscriptionResult
from jira_telegram_bot.use_cases.interface.speech_processor_interface import SpeechProcessorInterface
from jira_telegram_bot.use_cases.interface.task_handler_interface import TaskHandlerInterface
from jira_telegram_bot.use_cases.telegram_commands.advanced_task_creation import AdvancedTaskCreation

Global Initiations:
projects = self.advanced_task_creation.jira_repo.get_projects()
keyboard = []
current_row = []
reply_markup = InlineKeyboardMarkup(keyboard)
query = update.callback_query
project_key = query.data.split('|')[1]
project_info_path = os.path.join(DEFAULT_PATH, 'jira_telegram_bot/settings/projects_info.json')
query = update.callback_query
project_key = context.user_data['project_key']
project_info = context.user_data['project_info']
preview = text[:200] + '...' if len(text) > 200 else text
department_list = '\n'.join([f'• {dept}' for dept in project_info['departments'].keys()])
keyboard = [[InlineKeyboardButton('✅ Create Tasks', callback_data='confirm'), InlineKeyboardButton('❌ Cancel', callback_data='cancel')]]
reply_markup = InlineKeyboardMarkup(keyboard)
message_text = f'*Task Creation Preview*\n\n📝 *Description:*\n{preview}\n\n🏢 *Project:* {project_key}\n👥 *Available Departments:*\n{department_list}\n\nThe AI will:\n1️⃣ Create user stories\n2️⃣ Break down into component tasks\n3️⃣ Assign to team members\n4️⃣ Set story points & priorities\n\nWould you like to proceed?'
query = update.callback_query
query = update.callback_query
epic_key = query.data.split('|')[1]
keyboard = []
reply_markup = InlineKeyboardMarkup(keyboard)
query = update.callback_query
selection = query.data.split('|')[1]
project_key = context.user_data['project_key']
epic_key = context.user_data.get('epic_key')
query = update.callback_query
story_key = query.data.split('|')[1]
project_info = context.user_data['project_info']
dept_info = '\n'.join([f'👥 *{dept}*: {info['description']}' for dept, info in project_info['departments'].items()])
text = update.message.text
query = update.callback_query
project_key = context.user_data['project_key']
epics = self.advanced_task_creation.jira_repo.get_epics(project_key)
keyboard = []
current_row = []
reply_markup = InlineKeyboardMarkup(keyboard)
button = InlineKeyboardButton(project.name, callback_data=f'project|{project.key}')
projects_info = json.load(f)
epics = self.advanced_task_creation.jira_repo.get_epics(project_key)
keyboard = []
current_row = []
voice = update.message.voice
voice_file = await voice.get_file()
text = context.user_data.get('translated_text', context.user_data.get('original_text', ''))
text = update.message.text
user_story = await self.advanced_task_creation.create_structured_user_story(description=context.user_data['description'], project_key=context.user_data['project_key'], epic_key=context.user_data.get('epic_key'), parent_story_key=context.user_data.get('parent_story_key'))
created_tasks = await self.advanced_task_creation.create_tasks(description=context.user_data['description'], project_key=context.user_data['project_key'], task_type=context.user_data['task_type'], parent_story_key=context.user_data.get('parent_story_key'), epic_key=context.user_data.get('epic_key'))
stories = {}
response = '✅ *Successfully created the following structure:*\n\n'
project_info = context.user_data['project_info']
dept_info = '\n'.join([f'👥 *{dept}*: {info['description']}' for dept, info in project_info['departments'].items()])
button = InlineKeyboardButton(f'{epic.key}: {epic.fields.summary[:30]}...', callback_data=f'epic_select|{epic.key}')
current_row = []
reply_markup = InlineKeyboardMarkup(keyboard)
file_path = f'{DEFAULT_PATH}/{voice_file.file_path.split('/')[-1]}'
parts = [response[i:i + 4000] for i in range(0, len(response), 4000)]
stories = self.advanced_task_creation.jira_repo.get_stories_by_project(project_key, epic_key, status='"In Progress", "To Do", "Backlog", "Selected for Development"')
keyboard = []
current_row = []
reply_markup = InlineKeyboardMarkup(keyboard)
current_row = []
button = InlineKeyboardButton(f'{epic.fields.summary}', callback_data=f'epic|{epic.key}')
keyboard = [[InlineKeyboardButton('✅ Correct', callback_data='trans_confirm'), InlineKeyboardButton('❌ Try Again', callback_data='trans_retry')]]
reply_markup = InlineKeyboardMarkup(keyboard)
confidence_indicator = '🟢' if result.confidence > 0.8 else '🟡' if result.confidence > 0.6 else '🔴'
keyboard = [[InlineKeyboardButton('✅ Correct', callback_data='trans_confirm'), InlineKeyboardButton('❌ Try Again', callback_data='trans_retry')]]
reply_markup = InlineKeyboardMarkup(keyboard)
confidence_indicator = '🟢' if result.confidence > 0.8 else '🟡' if result.confidence > 0.6 else '🔴'
parent_key = task.fields.parent.key
button = InlineKeyboardButton(f'{story.fields.summary}', callback_data=f'story|{story.key}')
current_row = []
current_row = []

__main__ Section:


Classes and Methods:
Class: AdvancedTaskCreationHandler
  __init__ (self: Any, advanced_task_creation: AdvancedTaskCreation, speech_processor: SpeechProcessorInterface) -> None
  start (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: advanced_task_creation.jira_repo.get_projects
  select_project (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: advanced_task_creation.jira_repo.get_epics
  process_voice_message (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: speech_processor.process_voice_message
  handle_transcription_confirmation (self: Any, update: Update, context: CallbackContext) -> int
  process_description (self: Any, update: Update, context: CallbackContext, text: str) -> int
  create_tasks (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: advanced_task_creation.create_structured_user_story, advanced_task_creation.create_tasks
  cancel (self: Any, update: Update, context: CallbackContext) -> int
  select_epic (self: Any, update: Update, context: CallbackContext) -> int
  handle_task_type_selection (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: advanced_task_creation.jira_repo.get_stories_by_project
  handle_story_selection (self: Any, update: Update, context: CallbackContext) -> int
  process_text_description (self: Any, update: Update, context: CallbackContext) -> int
  handle_epic_selection (self: Any, update: Update, context: CallbackContext) -> int
      calls on dependencies: advanced_task_creation.jira_repo.get_epics
  get_handler (self: Any) -> None


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/frameworks/telegram/__init__.py
================================================================================

Imports:


Global Initiations:


__main__ Section:


Classes and Methods:


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/frameworks/telegram/user_settings_handler.py
================================================================================

Imports:
from __future__ import annotations
from telegram.ext import CallbackQueryHandler
from telegram.ext import CommandHandler
from telegram.ext import ConversationHandler
from telegram.ext import filters
from telegram.ext import MessageHandler
from jira_telegram_bot.use_cases.interface.task_handler_interface import TaskHandlerInterface
from jira_telegram_bot.use_cases.telegram_commands.user_settings import UserSettingsConversation

Global Initiations:


__main__ Section:


Classes and Methods:
Class: UserSettingsHandler
  __init__ (self: Any, settings_use_case: UserSettingsConversation) -> None
  get_handler (self: Any) -> None
  cancel (self: Any, update: Any, context: Any) -> None


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/frameworks/telegram/task_status_handler.py
================================================================================

Imports:
from __future__ import annotations
from telegram.ext import CommandHandler
from telegram.ext import ConversationHandler
from telegram.ext import filters
from telegram.ext import MessageHandler
from jira_telegram_bot.use_cases.interface.task_handler_interface import TaskHandlerInterface
from jira_telegram_bot.use_cases.telegram_commands.task_status import TaskStatus

Global Initiations:


__main__ Section:


Classes and Methods:
Class: TaskStatusHandler
  __init__ (self: Any, task_status_use_case: TaskStatus) -> None
  get_handler (self: Any) -> None
  cancel (self: Any, update: Any, context: Any) -> None


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/frameworks/telegram/task_transition_handler.py
================================================================================

Imports:
from __future__ import annotations
from telegram.ext import CallbackQueryHandler
from telegram.ext import CommandHandler
from telegram.ext import ConversationHandler
from jira_telegram_bot.use_cases.interface.task_handler_interface import TaskHandlerInterface
from jira_telegram_bot.use_cases.telegram_commands.transition_task import JiraTaskTransition

Global Initiations:


__main__ Section:


Classes and Methods:
Class: TaskTransitionHandler
  __init__ (self: Any, task_transition_use_case: JiraTaskTransition) -> None
  get_handler (self: Any) -> None
  cancel (self: Any, update: Any, context: Any) -> None


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/frameworks/telegram/board_summary_generator_handler.py
================================================================================

Imports:
from __future__ import annotations
from telegram.ext import CallbackQueryHandler
from telegram.ext import CommandHandler
from telegram.ext import ConversationHandler
from telegram.ext import filters
from telegram.ext import MessageHandler
from jira_telegram_bot.use_cases.telegram_commands.board_summary_generator import BoardSummaryGenerator
from jira_telegram_bot.use_cases.interface.task_handler_interface import TaskHandlerInterface

Global Initiations:


__main__ Section:


Classes and Methods:
Class: BoardSummaryGeneratorHandler
  __init__ (self: Any, board_summary_generator: BoardSummaryGenerator) -> None
  get_handler (self: Any) -> None
  cancel (self: Any, update: Any, context: Any) -> None


================================================================================
File: /home/ali/project/jirabot/jira_telegram_bot/frameworks/telegram/task_creation_handler.py
================================================================================

Imports:
from __future__ import annotations
from telegram.ext import CallbackQueryHandler
from telegram.ext import CommandHandler
from telegram.ext import ConversationHandler
from telegram.ext import filters
from telegram.ext import MessageHandler
from jira_telegram_bot.use_cases.telegram_commands.create_task import JiraTaskCreation
from jira_telegram_bot.use_cases.interface.task_handler_interface import TaskHandlerInterface

Global Initiations:


__main__ Section:


Classes and Methods:
Class: TaskCreationHandler
  __init__ (self: Any, task_creation_use_case: JiraTaskCreation) -> None
  get_handler (self: Any) -> None
  cancel (self: Any, update: Any, context: Any) -> None


================================================================================
File: /home/ali/project/jirabot/tests/unit_tests/test_advanced_task_creation.py
================================================================================

Imports:
from __future__ import annotations
from unittest import IsolatedAsyncioTestCase
from unittest.mock import AsyncMock
from unittest.mock import Mock
from jira_telegram_bot.use_cases.telegram_commands.advanced_task_creation import AdvancedTaskCreation

Global Initiations:
description = '\n        We need to implement a user authentication system with the following features:\n        - Login page with email/password\n        - Password reset functionality\n        - User profile management\n        '
tasks = await self.creator.create_tasks(description, 'PARSCHAT')
story_tasks = [t for t in tasks if t.fields.issuetype.name == 'Story']
subtasks = [t for t in tasks if t.fields.issuetype.name == 'Sub-task']
frontend_tasks = [t for t in tasks if 'frontend' in [c.name for c in t.fields.components]]
backend_tasks = [t for t in tasks if 'backend' in [c.name for c in t.fields.components]]
voice_text = 'Create a dashboard showing user statistics with graphs and data tables'
tasks = await self.creator.create_tasks(voice_text, 'PARSCHAT')
components_used = set()
description = 'Implement OAuth2 authentication with Google and Facebook'
tasks = await self.creator.create_tasks(description, 'PARSCHAT')
description = 'Implement complex data processing pipeline with ML models'
tasks = await self.creator.create_tasks(description, 'PARSCHAT')
description = '\n        Implement a machine learning model for chat message classification with the following:\n        - Data preprocessing pipeline\n        - Model training infrastructure\n        - API endpoints for predictions\n        - Frontend interface for testing the model\n        '
tasks = await self.creator.create_tasks(description, 'PARSCHAT')
stories = [t for t in tasks if t.fields.issuetype.name == 'Story']
subtasks = [t for t in tasks if t.fields.issuetype.name == 'Sub-task']
frontend_tasks = [t for t in tasks if 'frontend' in [c.name for c in t.fields.components]]
backend_tasks = [t for t in tasks if 'backend' in [c.name for c in t.fields.components]]
points = task.fields.customfield_10106

__main__ Section:


Classes and Methods:
Class: TestAdvancedTaskCreation
  asyncSetUp (self: Any) -> None
  test_task_decomposition (self: Any) -> None
  test_voice_input_processing (self: Any) -> None
  test_story_point_allocation (self: Any) -> None
  test_skill_based_assignment (self: Any) -> None
  test_ml_project_task_creation (self: Any) -> None


================================================================================
File: /home/ali/project/jirabot/tests/unit_tests/use_cases/test_create_easy_task.py
================================================================================

Imports:
from __future__ import annotations
import unittest
from io import BytesIO
from unittest.mock import AsyncMock
from unittest.mock import MagicMock
from unittest.mock import patch
from telegram import InlineKeyboardButton
from telegram import InlineKeyboardMarkup
from telegram import Message
from telegram import Update
from telegram import User
from telegram.ext import CallbackContext
from jira_telegram_bot.adapters.user_config import UserConfig
from jira_telegram_bot.entities.field_config import FieldConfig
from jira_telegram_bot.entities.task import TaskData
from jira_telegram_bot.use_cases.create_easy_task import JiraEasyTaskCreation
from jira_telegram_bot.use_cases.interface.task_manager_repository_interface import TaskManagerRepositoryInterface
from jira_telegram_bot import DEFAULT_PATH

Global Initiations:
task_data = self.context.user_data['task_data']
query = MagicMock()
query = MagicMock()
query = MagicMock()
query = MagicMock()
query = MagicMock()
query = MagicMock()
query = MagicMock()
task_data = TaskData()
issue_fields = self.task_creation.build_issue_fields(task_data)
expected_fields = {'project': {'key': 'PA'}, 'summary': 'Test Summary', 'description': 'Test Description', 'issuetype': {'name': 'Task'}, 'components': [{'name': 'Component X'}], 'customfield_10106': 5.0, 'customfield_10104': 101, 'customfield_10105': 'EPIC-1', 'fixVersions': [{'name': 'Version 1.0'}]}
query = MagicMock()
issue = MagicMock()
attachments = {'images': [BytesIO(b'fake image data')], 'videos': [BytesIO(b'fake video data')], 'audio': [BytesIO(b'fake audio data')], 'documents': [BytesIO(b'fake document data')]}
mock_response = AsyncMock()
valid_image_data = f.read()

__main__ Section:
if __name__ == '__main__':
    unittest.main()

Classes and Methods:
Class: TestJiraEasyTaskCreation
  setUp (self: Any) -> None
  test_start_with_user_config_project (self: Any, mock_check_user_allowed: Any) -> None
  test_start_without_user_config_project (self: Any, mock_check_user_allowed: Any) -> None
  test_add_project (self: Any) -> None
  test_add_summary (self: Any) -> None
  test_add_description (self: Any) -> None
  test_add_component (self: Any) -> None
  test_add_task_type (self: Any) -> None
  test_add_story_points (self: Any) -> None
  test_add_sprint (self: Any) -> None
  test_add_epic_link (self: Any) -> None
  test_add_release (self: Any) -> None
  test_add_attachment_skip (self: Any) -> None
  test_add_attachment_with_files (self: Any) -> None
  test_build_issue_fields (self: Any) -> None
  test_send_message_with_message (self: Any) -> None
  test_send_message_with_callback_query (self: Any) -> None
  test_send_message_error (self: Any) -> None
  test_handle_attachments (self: Any) -> None
  test_get_file_extension (self: Any) -> None


